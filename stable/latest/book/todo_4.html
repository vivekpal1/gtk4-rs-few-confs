<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Adding Collections - GUI development with Rust and GTK 4</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/style.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">1.</strong> Installation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="installation_linux.html"><strong aria-hidden="true">1.1.</strong> Linux</a></li><li class="chapter-item expanded "><a href="installation_macos.html"><strong aria-hidden="true">1.2.</strong> macOS</a></li><li class="chapter-item expanded "><a href="installation_windows.html"><strong aria-hidden="true">1.3.</strong> Windows</a></li></ol></li><li class="chapter-item expanded "><a href="project_setup.html"><strong aria-hidden="true">2.</strong> Project Setup</a></li><li class="chapter-item expanded "><a href="hello_world.html"><strong aria-hidden="true">3.</strong> Hello World!</a></li><li class="chapter-item expanded "><a href="widgets.html"><strong aria-hidden="true">4.</strong> Widgets</a></li><li class="chapter-item expanded "><a href="g_object_concepts.html"><strong aria-hidden="true">5.</strong> GObject Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="g_object_memory_management.html"><strong aria-hidden="true">5.1.</strong> Memory Management</a></li><li class="chapter-item expanded "><a href="g_object_subclassing.html"><strong aria-hidden="true">5.2.</strong> Subclassing</a></li><li class="chapter-item expanded "><a href="g_object_values.html"><strong aria-hidden="true">5.3.</strong> Generic Values</a></li><li class="chapter-item expanded "><a href="g_object_properties.html"><strong aria-hidden="true">5.4.</strong> Properties</a></li><li class="chapter-item expanded "><a href="g_object_signals.html"><strong aria-hidden="true">5.5.</strong> Signals</a></li></ol></li><li class="chapter-item expanded "><a href="main_event_loop.html"><strong aria-hidden="true">6.</strong> The Main Event Loop</a></li><li class="chapter-item expanded "><a href="settings.html"><strong aria-hidden="true">7.</strong> Settings</a></li><li class="chapter-item expanded "><a href="saving_window_state.html"><strong aria-hidden="true">8.</strong> Saving Window State</a></li><li class="chapter-item expanded "><a href="list_widgets.html"><strong aria-hidden="true">9.</strong> List Widgets</a></li><li class="chapter-item expanded "><a href="composite_templates.html"><strong aria-hidden="true">10.</strong> Composite Templates</a></li><li class="chapter-item expanded "><a href="todo_1.html"><strong aria-hidden="true">11.</strong> Building a Simple To-Do App</a></li><li class="chapter-item expanded "><a href="actions.html"><strong aria-hidden="true">12.</strong> Actions</a></li><li class="chapter-item expanded "><a href="todo_2.html"><strong aria-hidden="true">13.</strong> Manipulating State of To-Do App</a></li><li class="chapter-item expanded "><a href="css.html"><strong aria-hidden="true">14.</strong> CSS</a></li><li class="chapter-item expanded "><a href="libadwaita.html"><strong aria-hidden="true">15.</strong> Libadwaita</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="todo_3.html"><strong aria-hidden="true">15.1.</strong> Let To-Do App use Libadwaita</a></li><li class="chapter-item expanded "><a href="todo_4.html" class="active"><strong aria-hidden="true">15.2.</strong> Adding Collections</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">GUI development with Rust and GTK 4</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/gtk-rs/gtk4-rs/tree/master/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="adding-collections"><a class="header" href="#adding-collections">Adding Collections</a></h1>
<h2 id="sidebar"><a class="header" href="#sidebar">Sidebar</a></h2>
<p>Using Libadwaita on its own was already a big leap forward when it came to the look and feel of the To-Do app.
Let us go one step further by adding a way to group tasks into collections.
These collections will get their own sidebar on the left of the app.
We will start by adding an empty sidebar without any functionality.</p>
<div style="text-align:center"><img src="img/todo_7_sidebar.png" alt="To-Do app with an empty sidebar"/></div>
<p>There are a couple of steps we have to go through to get to this state.
First, we have to replace <a href="../docs/gtk4/struct.ApplicationWindow.html"><code>gtk::ApplicationWindow</code></a> with <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/struct.ApplicationWindow.html"><code>adw::ApplicationWindow</code></a>.
The only difference between those two is that <code>adw::ApplicationWindow</code> has no titlebar area.
That comes in handy when we build up our interface with <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/struct.Leaflet.html"><code>adw::Leaflet</code></a>.
In the screenshot above, the <code>Leaflet</code> behaves like a <a href="../docs/gtk4/struct.Box.html"><code>gtk::Box</code></a> and contains the collection view on the left, a separator in the middle and the task view on the right.
When using <code>adw::ApplicationWindow</code> the collection view and task view have their own <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/struct.HeaderBar.html"><code>adw::HeaderBar</code></a> and the separator spans over the whole window.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/7/resources/window.ui">listings/todo/7/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;interface&gt;
  &lt;menu id=&quot;main-menu&quot;&gt;
    &lt;!--Menu implementation--&gt;      
  &lt;/menu&gt;
  &lt;template class=&quot;TodoWindow&quot; parent=&quot;AdwApplicationWindow&quot;&gt;
    &lt;property name=&quot;title&quot; translatable=&quot;yes&quot;&gt;To-Do&lt;/property&gt;
    &lt;property name=&quot;default_width&quot;&gt;650&lt;/property&gt;
    &lt;property name=&quot;default_height&quot;&gt;550&lt;/property&gt;
    &lt;property name=&quot;content&quot;&gt;
      &lt;object class=&quot;AdwLeaflet&quot; id=&quot;leaflet&quot;&gt;
        &lt;property name=&quot;can-navigate-back&quot;&gt;True&lt;/property&gt;
        &lt;child&gt;
          &lt;object class=&quot;GtkBox&quot;&gt;
            &lt;!--Collection view implementation--&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child&gt;
          &lt;object class=&quot;AdwLeafletPage&quot;&gt;
            &lt;property name=&quot;navigatable&quot;&gt;False&lt;/property&gt;
            &lt;property name=&quot;child&quot;&gt;
              &lt;object class=&quot;GtkSeparator&quot; /&gt;
            &lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child&gt;
          &lt;object class=&quot;GtkBox&quot;&gt;
            &lt;!--Task view implementation--&gt;
          &lt;/object&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/property&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>The <code>Leaflet</code> does not always behave like a <code>gtk::Box</code>.
As soon as the requested size is too small to fit all children at the same time, the leaflet folds, and starts behaving like a <a href="../docs/gtk4/struct.Stack.html"><code>gtk::Stack</code></a>.
This means that it only displays one of its children at a time.
The property &quot;can-navigate-back&quot; controls whether gestures and shortcuts for navigating backward are enabled.
The <code>AdwLeafletPage</code> with the <code>gtk::Separator</code> will never be displayed in the folded state since its property &quot;navigatable&quot; is set to <code>False</code>.)
The adaptive behavior of the leaflet allows the To-Do app to work on smaller screen sizes even with the added collection view.</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/todo_7_leaflet.webm" type="video/webm">
   <p>A video which shows that reduzing the width of the app let's the sidebar collapse</p>
 </video>
</div>
<p>We add the necessary UI elements for the collection view, such as a header bar with a button to add a new collection, as well as the list box <code>collections_list</code> to display the collections later on.</p>
<p>As you can see in the screencast above, the header bar also displays a close button if the leaflet is folded.
We include this logic with an expression which can be built up in the UI file with the tag <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Expression.html#gtkexpression-in-ui-files"><code>lookup</code></a>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/7/resources/window.ui">listings/todo/7/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;object class=&quot;GtkBox&quot;&gt;
  &lt;property name=&quot;orientation&quot;&gt;vertical&lt;/property&gt;
  &lt;property name=&quot;width-request&quot;&gt;200&lt;/property&gt;
  &lt;child&gt;
    &lt;object class=&quot;AdwHeaderBar&quot;&gt;
      &lt;binding name=&quot;show-end-title-buttons&quot;&gt;
        &lt;lookup name=&quot;folded&quot;&gt;leaflet&lt;/lookup&gt;
      &lt;/binding&gt;
      &lt;child type=&quot;start&quot;&gt;
        &lt;object class=&quot;GtkToggleButton&quot;&gt;
          &lt;property name=&quot;icon-name&quot;&gt;list-add-symbolic&lt;/property&gt;
          &lt;property name=&quot;tooltip-text&quot; translatable=&quot;yes&quot;&gt;New Collection&lt;/property&gt;
          &lt;property name=&quot;action-name&quot;&gt;win.new-collection&lt;/property&gt;
        &lt;/object&gt;
      &lt;/child&gt;
    &lt;/object&gt;
  &lt;/child&gt;
  &lt;child&gt;
    &lt;object class=&quot;GtkScrolledWindow&quot;&gt;
      &lt;property name=&quot;vexpand&quot;&gt;True&lt;/property&gt;
      &lt;property name=&quot;child&quot;&gt;
        &lt;object class=&quot;GtkListBox&quot; id=&quot;collections_list&quot;&gt;
          &lt;style&gt;
            &lt;class name=&quot;navigation-sidebar&quot; /&gt;
          &lt;/style&gt;
        &lt;/object&gt;
      &lt;/property&gt;
    &lt;/object&gt;
  &lt;/child&gt;
&lt;/object&gt;
</code></pre>
<p>We also add a header bar to the task view.
We don't have to worry about the close button here: it will always be displayed.
However, we will need a way to go back to the collection view when the leaflet is folded.
That is why we add <code>back_button</code> which can be used to return to the collection view and which is only visible when the leaflet is folded. </p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/7/resources/window.ui">listings/todo/7/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;object class=&quot;GtkBox&quot;&gt;
  &lt;property name=&quot;orientation&quot;&gt;vertical&lt;/property&gt;
  &lt;property name=&quot;hexpand&quot;&gt;True&lt;/property&gt;
  &lt;property name=&quot;width-request&quot;&gt;250&lt;/property&gt; 
  &lt;child&gt;
    &lt;object class=&quot;AdwHeaderBar&quot;&gt;
      &lt;property name=&quot;title-widget&quot;&gt;
        &lt;object class=&quot;AdwWindowTitle&quot; /&gt;
      &lt;/property&gt;
      &lt;child type=&quot;start&quot;&gt;
        &lt;object class=&quot;GtkButton&quot; id=&quot;back_button&quot;&gt;
          &lt;binding name=&quot;visible&quot;&gt;
            &lt;lookup name=&quot;folded&quot;&gt;leaflet&lt;/lookup&gt;
          &lt;/binding&gt;
          &lt;property name=&quot;icon-name&quot;&gt;go-previous-symbolic&lt;/property&gt;
          &lt;property name=&quot;tooltip-text&quot; translatable=&quot;yes&quot;&gt;Back&lt;/property&gt;
        &lt;/object&gt;
      &lt;/child&gt;
      &lt;child type=&quot;end&quot;&gt;
        &lt;object class=&quot;GtkMenuButton&quot;&gt;
          &lt;property name=&quot;icon-name&quot;&gt;open-menu-symbolic&lt;/property&gt;
          &lt;property name=&quot;menu-model&quot;&gt;main-menu&lt;/property&gt;
          &lt;property name=&quot;tooltip-text&quot; translatable=&quot;yes&quot;&gt;Main Menu&lt;/property&gt;
        &lt;/object&gt;
      &lt;/child&gt;
    &lt;/object&gt;
  &lt;/child&gt;
  &lt;child&gt;
    &lt;!--This part stays the same--&gt;
  &lt;/child&gt;
&lt;/object&gt;
</code></pre>
<p>We also have to adapt the window implementation.
For example, the parent type of our window is now <code>adw::ApplicationWindow</code> instead of <code>gtk::ApplicationWindow</code>. </p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/7/window/imp.rs">listings/todo/7/window/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::signal::Inhibit;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, ListBox};
</span><span class="boring">use once_cell::sync::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = &quot;/org/gtk_rs/Todo7/window.ui&quot;)]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    pub tasks: RefCell&lt;Option&lt;gio::ListStore&gt;&gt;,
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for Window {
    // `NAME` needs to match `class` attribute of template
    const NAME: &amp;'static str = &quot;TodoWindow&quot;;
    type Type = super::Window;
    //                👇 changed
    type ParentType = adw::ApplicationWindow;

    fn class_init(klass: &amp;mut Self::Class) {
        klass.bind_template();
    }

    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
        obj.init_template();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call &quot;constructed&quot; on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_tasks();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; Inhibit {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;TaskData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .tasks()
</span><span class="boring">            .snapshot()
</span><span class="boring">            .iter()
</span><span class="boring">            .filter_map(Cast::downcast_ref::&lt;TaskObject&gt;)
</span><span class="boring">            .map(TaskObject::task_data)
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect(&quot;Could not create json file.&quot;);
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect(&quot;Could not write data to json file&quot;);
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all adwaita application windows
</span><span class="boring">impl AdwApplicationWindowImpl for Window {}</span></code></pre>
<p>That also means that we have to implement the trait <code>AdwApplicationWindowImpl</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/7/window/imp.rs">listings/todo/7/window/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::signal::Inhibit;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, ListBox};
</span><span class="boring">use once_cell::sync::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = &quot;/org/gtk_rs/Todo7/window.ui&quot;)]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    pub tasks: RefCell&lt;Option&lt;gio::ListStore&gt;&gt;,
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = &quot;TodoWindow&quot;;
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    //                👇 changed
</span><span class="boring">    type ParentType = adw::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call &quot;constructed&quot; on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_tasks();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; Inhibit {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;TaskData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .tasks()
</span><span class="boring">            .snapshot()
</span><span class="boring">            .iter()
</span><span class="boring">            .filter_map(Cast::downcast_ref::&lt;TaskObject&gt;)
</span><span class="boring">            .map(TaskObject::task_data)
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect(&quot;Could not create json file.&quot;);
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect(&quot;Could not write data to json file&quot;);
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span><span class="boring">
</span>// Trait shared by all adwaita application windows
impl AdwApplicationWindowImpl for Window {}</code></pre>
<p>Finally, we add <code>adw::ApplicationWindow</code> to the ancestors of <code>Window</code> in <code>mod.rs</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/7/window/mod.rs">listings/todo/7/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{prelude::*, ActionRow};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::glib::BindingFlags;
</span><span class="boring">use gtk::{gio, glib, Align, CheckButton, CustomFilter, FilterListModel, NoSelection};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span>glib::wrapper! {
    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
        //       👇 changed
        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
}
<span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property(&quot;application&quot;, app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect(&quot;`settings` should not be set before calling `setup_settings`.&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect(&quot;`settings` should be set in `setup_settings`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect(&quot;Could not get current tasks.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get(&quot;filter&quot;);
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            &quot;All&quot; =&gt; None,
</span><span class="boring">            &quot;Open&quot; =&gt; Some(filter_open),
</span><span class="boring">            &quot;Done&quot; =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new(TaskObject::static_type());
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let filter_model = FilterListModel::new(Some(self.tasks()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(@weak self as window =&gt; @default-panic, move |obj| {
</span><span class="boring">                let task_object = obj.downcast_ref().expect(&quot;The object should be of type `TaskObject`.&quot;);
</span><span class="boring">                let row = window.create_task_row(task_object);
</span><span class="boring">                row.upcast()
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key &quot;filter&quot; changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some(&quot;filter&quot;),
</span><span class="boring">            clone!(@weak self as window, @weak filter_model =&gt; move |_, _| {
</span><span class="boring">                filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;self.tasks());
</span><span class="boring">        self.tasks().connect_items_changed(
</span><span class="boring">            clone!(@weak self as window =&gt; move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Assure that `tasks_list` is only visible
</span><span class="boring">    /// if the number of tasks is greater than 0
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TaskData&gt; = serde_json::from_reader(file).expect(
</span><span class="boring">                &quot;It should be possible to read `backup_data` from the json file.&quot;,
</span><span class="boring">            );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TaskData&gt;` to `Vec&lt;TaskObject&gt;`
</span><span class="boring">            let task_objects: Vec&lt;TaskObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(TaskObject::from_task_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.tasks().extend_from_slice(&amp;task_objects);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property(&quot;completed&quot;, &amp;check_button, &quot;active&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE | BindingFlags::BIDIRECTIONAL)
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property(&quot;content&quot;, &amp;row, &quot;title&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp()
</span><span class="boring">            .entry
</span><span class="boring">            .connect_activate(clone!(@weak self as window =&gt; move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_,_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text(&quot;&quot;);
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key &quot;filter&quot; and add to action group &quot;win&quot;
</span><span class="boring">        let action_filter = self.settings().create_action(&quot;filter&quot;);
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group &quot;win&quot;
</span><span class="boring">        let action_remove_done_tasks =
</span><span class="boring">            gio::SimpleAction::new(&quot;remove-done-tasks&quot;, None);
</span><span class="boring">        action_remove_done_tasks.connect_activate(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, _| {
</span><span class="boring">                let tasks = window.tasks();
</span><span class="boring">                let mut position = 0;
</span><span class="boring">                while let Some(item) = tasks.item(position) {
</span><span class="boring">                    // Get `TaskObject` from `glib::Object`
</span><span class="boring">                    let task_object = item
</span><span class="boring">                        .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                        .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">                    if task_object.is_completed() {
</span><span class="boring">                        tasks.remove(position);
</span><span class="boring">                    } else {
</span><span class="boring">                        position += 1;
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">        self.add_action(&amp;action_remove_done_tasks);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<h2 id="placeholder-page"><a class="header" href="#placeholder-page">Placeholder Page</a></h2>
<p>Even before we start to populate the collection view, we ought to think about a different challenge: the empty state of our To-Do app.
Before, the empty state without a single task was quite okay.
It was clear that you had to add tasks in the entry bar.
However, now the situation is different.
Users will have to add a collection first, and we have to make that clear.
The GNOME HIG suggests to use a <a href="https://developer.gnome.org/hig/patterns/feedback/placeholders.html">placeholder page</a> for that.
In our case, this placeholder page will be presented to the user if they open the app without any collections present.</p>
<div style="text-align:center"><img src="img/todo_8_placeholder_page.png" alt="The placeholder page"/></div>
<p>We now wrap our UI in a <a href="../docs/gtk4/struct.Stack.html"><code>gtk::Stack</code></a>.
One stack page describes the placeholder page, the other describes the main page.
We will later wire up the logic to display the correct stack page in the Rust code.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/resources/window.ui">listings/todo/8/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;interface&gt;
  &lt;menu id=&quot;main-menu&quot;&gt;
    &lt;!--Menu implementation--&gt; 
  &lt;/menu&gt;
  &lt;template class=&quot;TodoWindow&quot; parent=&quot;AdwApplicationWindow&quot;&gt;
    &lt;property name=&quot;title&quot; translatable=&quot;yes&quot;&gt;To-Do&lt;/property&gt;
    &lt;property name=&quot;default_width&quot;&gt;650&lt;/property&gt;
    &lt;property name=&quot;default_height&quot;&gt;550&lt;/property&gt;
    &lt;property name=&quot;content&quot;&gt;
      &lt;object class=&quot;GtkStack&quot; id=&quot;stack&quot;&gt;
        &lt;property name=&quot;transition-type&quot;&gt;crossfade&lt;/property&gt;
        &lt;child&gt;
          &lt;object class=&quot;GtkStackPage&quot;&gt;
            &lt;property name=&quot;name&quot;&gt;empty&lt;/property&gt;
            &lt;property name=&quot;child&quot;&gt;
              &lt;object class=&quot;GtkBox&quot;&gt;
                &lt;!--Placeholder page implementation--&gt; 
              &lt;/object&gt;
            &lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child&gt;
          &lt;object class=&quot;GtkStackPage&quot;&gt;
            &lt;property name=&quot;name&quot;&gt;main&lt;/property&gt;
            &lt;property name=&quot;child&quot;&gt;
              &lt;object class=&quot;AdwLeaflet&quot; id=&quot;leaflet&quot;&gt;
                &lt;!--Main page implementation--&gt;
              &lt;/object&gt;
            &lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/property&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>In order to create the pageholder page as displayed before, we combine a flat header bar with <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/struct.StatusPage.html"><code>adw::StatusPage</code></a>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/resources/window.ui">listings/todo/8/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;object class=&quot;GtkBox&quot;&gt;
  &lt;property name=&quot;orientation&quot;&gt;vertical&lt;/property&gt;
  &lt;child&gt;
    &lt;object class=&quot;GtkHeaderBar&quot;&gt;
      &lt;style&gt;
        &lt;class name=&quot;flat&quot; /&gt;
      &lt;/style&gt;
    &lt;/object&gt;
  &lt;/child&gt;
  &lt;child&gt;
    &lt;object class=&quot;GtkWindowHandle&quot;&gt;
      &lt;property name=&quot;vexpand&quot;&gt;True&lt;/property&gt;
      &lt;property name=&quot;child&quot;&gt;
        &lt;object class=&quot;AdwStatusPage&quot;&gt;
          &lt;property name=&quot;icon-name&quot;&gt;checkbox-checked-symbolic&lt;/property&gt;
          &lt;property name=&quot;title&quot; translatable=&quot;yes&quot;&gt;No Tasks&lt;/property&gt;
          &lt;property name=&quot;description&quot; translatable=&quot;yes&quot;&gt;Create some tasks to start using the app.&lt;/property&gt;
          &lt;property name=&quot;child&quot;&gt;
            &lt;object class=&quot;GtkButton&quot;&gt;
              &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;_New Collection&lt;/property&gt;
              &lt;property name=&quot;use-underline&quot;&gt;True&lt;/property&gt;
              &lt;property name=&quot;halign&quot;&gt;center&lt;/property&gt;
              &lt;property name=&quot;action-name&quot;&gt;win.new-collection&lt;/property&gt;
              &lt;style&gt;
                &lt;class name=&quot;pill&quot; /&gt;
                &lt;class name=&quot;suggested-action&quot; /&gt;
              &lt;/style&gt;
            &lt;/object&gt;
          &lt;/property&gt;
        &lt;/object&gt;
      &lt;/property&gt;
    &lt;/object&gt;
  &lt;/child&gt;
&lt;/object&gt;
</code></pre>
<h2 id="collections"><a class="header" href="#collections">Collections</a></h2>
<p>We still need a way to store our collections.
Just like we have already created <code>TaskObject</code>, we will now introduce <code>CollectionObject</code>.
It will have the members <code>title</code> and <code>tasks</code>, both of which will be exposed as properties.
As usual, the full implementation can be seen by clicking at the eye symbol at the top right of the snippet. </p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/collection_object/imp.rs">listings/todo/8/collection_object/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use glib::{ParamSpec, ParamSpecString, Value};
</span><span class="boring">use gtk::glib::ParamSpecObject;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use once_cell::sync::{Lazy, OnceCell};
</span><span class="boring">
</span>// Object holding the state
#[derive(Default)]
pub struct CollectionObject {
    pub title: RefCell&lt;String&gt;,
    pub tasks: OnceCell&lt;gio::ListStore&gt;,
}

// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for CollectionObject {
    const NAME: &amp;'static str = &quot;TodoCollectionObject&quot;;
    type Type = super::CollectionObject;
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for CollectionObject {
</span><span class="boring">    fn properties() -&gt; &amp;'static [ParamSpec] {
</span><span class="boring">        static PROPERTIES: Lazy&lt;Vec&lt;ParamSpec&gt;&gt; = Lazy::new(|| {
</span><span class="boring">            vec![
</span><span class="boring">                ParamSpecString::builder(&quot;title&quot;).build(),
</span><span class="boring">                ParamSpecObject::builder::&lt;gio::ListStore&gt;(&quot;tasks&quot;).build(),
</span><span class="boring">            ]
</span><span class="boring">        });
</span><span class="boring">        PROPERTIES.as_ref()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_property(&amp;self, _id: usize, value: &amp;Value, pspec: &amp;ParamSpec) {
</span><span class="boring">        match pspec.name() {
</span><span class="boring">            &quot;title&quot; =&gt; {
</span><span class="boring">                let input_value = value
</span><span class="boring">                    .get()
</span><span class="boring">                    .expect(&quot;The value needs to be of type `String`.&quot;);
</span><span class="boring">                self.title.replace(input_value);
</span><span class="boring">            }
</span><span class="boring">            &quot;tasks&quot; =&gt; {
</span><span class="boring">                let input_value = value
</span><span class="boring">                    .get()
</span><span class="boring">                    .expect(&quot;The value needs to be of type `gio::ListStore`.&quot;);
</span><span class="boring">                self.tasks.set(input_value).expect(&quot;Could not set task&quot;);
</span><span class="boring">            }
</span><span class="boring">            _ =&gt; unimplemented!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn property(&amp;self, _id: usize, pspec: &amp;ParamSpec) -&gt; Value {
</span><span class="boring">        match pspec.name() {
</span><span class="boring">            &quot;title&quot; =&gt; self.title.borrow().to_value(),
</span><span class="boring">            &quot;tasks&quot; =&gt; self.tasks.get().expect(&quot;Could not get tasks.&quot;).to_value(),
</span><span class="boring">            _ =&gt; unimplemented!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>We also add the struct <code>CollectionData</code> to aid in serialization and deserialization.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/collection_object/mod.rs">listings/todo/8/collection_object/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use adw::prelude::{ListModelExtManual, *};
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct CollectionObject(ObjectSubclass&lt;imp::CollectionObject&gt;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl CollectionObject {
</span><span class="boring">    pub fn new(title: &amp;str, tasks: gio::ListStore) -&gt; Self {
</span><span class="boring">        Object::builder()
</span><span class="boring">            .property(&quot;title&quot;, title)
</span><span class="boring">            .property(&quot;tasks&quot;, tasks)
</span><span class="boring">            .build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .get()
</span><span class="boring">            .expect(&quot;Could not get tasks.&quot;)
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn to_collection_data(&amp;self) -&gt; CollectionData {
</span><span class="boring">        let title = self.imp().title.borrow().clone();
</span><span class="boring">        let tasks_data = self
</span><span class="boring">            .tasks()
</span><span class="boring">            .snapshot()
</span><span class="boring">            .iter()
</span><span class="boring">            .filter_map(Cast::downcast_ref::&lt;TaskObject&gt;)
</span><span class="boring">            .map(TaskObject::task_data)
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        CollectionData { title, tasks_data }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn from_collection_data(collection_data: CollectionData) -&gt; Self {
</span><span class="boring">        let title = collection_data.title;
</span><span class="boring">        let tasks_to_extend: Vec&lt;TaskObject&gt; = collection_data
</span><span class="boring">            .tasks_data
</span><span class="boring">            .into_iter()
</span><span class="boring">            .map(TaskObject::from_task_data)
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        let tasks = gio::ListStore::new(TaskObject::static_type());
</span><span class="boring">        tasks.extend_from_slice(&amp;tasks_to_extend);
</span><span class="boring">
</span><span class="boring">        Self::new(&amp;title, tasks)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Default, Clone, Serialize, Deserialize)]
pub struct CollectionData {
    pub title: String,
    pub tasks_data: Vec&lt;TaskData&gt;,
}</code></pre>
<p>Finally, we add methods to <code>CollectionObject</code> in order to</p>
<ul>
<li>construct it with <code>new</code>,</li>
<li>easily access the tasks <code>ListStore</code> with <code>tasks</code> and</li>
<li>convert to and from <code>CollectionData</code> with <code>to_collection_data</code> and <code>from_collection_data</code>. </li>
</ul>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/collection_object/mod.rs">listings/todo/8/collection_object/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use adw::prelude::{ListModelExtManual, *};
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct CollectionObject(ObjectSubclass&lt;imp::CollectionObject&gt;);
</span><span class="boring">}
</span><span class="boring">
</span>impl CollectionObject {
    pub fn new(title: &amp;str, tasks: gio::ListStore) -&gt; Self {
        Object::builder()
            .property(&quot;title&quot;, title)
            .property(&quot;tasks&quot;, tasks)
            .build()
    }

    pub fn tasks(&amp;self) -&gt; gio::ListStore {
        self.imp()
            .tasks
            .get()
            .expect(&quot;Could not get tasks.&quot;)
            .clone()
    }

    pub fn to_collection_data(&amp;self) -&gt; CollectionData {
        let title = self.imp().title.borrow().clone();
        let tasks_data = self
            .tasks()
            .snapshot()
            .iter()
            .filter_map(Cast::downcast_ref::&lt;TaskObject&gt;)
            .map(TaskObject::task_data)
            .collect();

        CollectionData { title, tasks_data }
    }

    pub fn from_collection_data(collection_data: CollectionData) -&gt; Self {
        let title = collection_data.title;
        let tasks_to_extend: Vec&lt;TaskObject&gt; = collection_data
            .tasks_data
            .into_iter()
            .map(TaskObject::from_task_data)
            .collect();

        let tasks = gio::ListStore::new(TaskObject::static_type());
        tasks.extend_from_slice(&amp;tasks_to_extend);

        Self::new(&amp;title, tasks)
    }
}
<span class="boring">
</span><span class="boring">#[derive(Default, Clone, Serialize, Deserialize)]
</span><span class="boring">pub struct CollectionData {
</span><span class="boring">    pub title: String,
</span><span class="boring">    pub tasks_data: Vec&lt;TaskData&gt;,
</span><span class="boring">}</span></code></pre>
<h2 id="window"><a class="header" href="#window">Window</a></h2>
<p>In order to hook up the new logic, we have to add more state to <code>imp::Window</code>.
There are additional widgets that we access via the <code>template_child</code> macro.
Additionally, we reference the <code>collections</code> list store, the <code>current_collection</code> as well as the <code>current_filter_model</code>.
We also store <code>tasks_changed_handler_id</code>.
Its purpose will become clear in later snippets.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/7/window/imp.rs">listings/todo/8/window/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::Leaflet;
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::signal::Inhibit;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::glib::SignalHandlerId;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Button, CompositeTemplate, Entry, FilterListModel, ListBox, Stack,
</span><span class="boring">};
</span><span class="boring">use once_cell::sync::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span>// Object holding the state
#[derive(CompositeTemplate, Default)]
#[template(resource = &quot;/org/gtk_rs/Todo8/window.ui&quot;)]
pub struct Window {
    pub settings: OnceCell&lt;Settings&gt;,
    #[template_child]
    pub entry: TemplateChild&lt;Entry&gt;,
    #[template_child]
    pub tasks_list: TemplateChild&lt;ListBox&gt;,
    // 👇 all members below are new
    #[template_child]
    pub collections_list: TemplateChild&lt;ListBox&gt;,
    #[template_child]
    pub leaflet: TemplateChild&lt;Leaflet&gt;,
    #[template_child]
    pub stack: TemplateChild&lt;Stack&gt;,
    #[template_child]
    pub back_button: TemplateChild&lt;Button&gt;,
    pub collections: OnceCell&lt;gio::ListStore&gt;,
    pub current_collection: RefCell&lt;Option&lt;CollectionObject&gt;&gt;,
    pub current_filter_model: RefCell&lt;Option&lt;FilterListModel&gt;&gt;,
    pub tasks_changed_handler_id: RefCell&lt;Option&lt;SignalHandlerId&gt;&gt;,
}
<span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = &quot;TodoWindow&quot;;
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = adw::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call &quot;constructed&quot; on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_collections();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; Inhibit {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;CollectionData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .collections()
</span><span class="boring">            .snapshot()
</span><span class="boring">            .iter()
</span><span class="boring">            .filter_map(Cast::downcast_ref::&lt;CollectionObject&gt;)
</span><span class="boring">            .map(CollectionObject::to_collection_data)
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect(&quot;Could not create json file.&quot;);
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect(&quot;Could not write data to json file&quot;);
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all adwaita application windows
</span><span class="boring">impl AdwApplicationWindowImpl for Window {}</span></code></pre>
<p>Further, we add a couple of helper methods which will come in handy later on.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, NavigationDirection};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::glib::BindingFlags;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Dialog, DialogFlags, Entry,
</span><span class="boring">    FilterListModel, Label, ListBoxRow, NoSelection, ResponseType, SelectionMode,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property(&quot;application&quot;, app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect(&quot;`settings` should not be set before calling `setup_settings`.&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect(&quot;`settings` should be set in `setup_settings`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span>    fn tasks(&amp;self) -&gt; gio::ListStore {
        self.current_collection().tasks()
    }

    fn current_collection(&amp;self) -&gt; CollectionObject {
        self.imp()
            .current_collection
            .borrow()
            .clone()
            .expect(&quot;`current_collection` should be set in `set_current_collections`.&quot;)
    }

    fn collections(&amp;self) -&gt; gio::ListStore {
        self.imp()
            .collections
            .get()
            .expect(&quot;`collections` should be set in `setup_collections`.&quot;)
            .clone()
    }

    fn set_filter(&amp;self) {
        self.imp()
            .current_filter_model
            .borrow()
            .clone()
            .expect(&quot;`current_filter_model` should be set in `set_current_collection`.&quot;)
            .set_filter(self.filter().as_ref());
    }
<span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get(&quot;filter&quot;);
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            &quot;All&quot; =&gt; None,
</span><span class="boring">            &quot;Open&quot; =&gt; Some(filter_open),
</span><span class="boring">            &quot;Done&quot; =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new(CollectionObject::static_type());
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect(&quot;Could not set collections&quot;);
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(@weak self as window =&gt; @default-panic, move |obj| {
</span><span class="boring">                let collection_object = obj
</span><span class="boring">                    .downcast_ref()
</span><span class="boring">                    .expect(&quot;The object should be of type `CollectionObject`.&quot;);
</span><span class="boring">                let row = window.create_collection_row(collection_object);
</span><span class="boring">                row.upcast()
</span><span class="boring">            }),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    &quot;It should be possible to read `backup_data` from the json file.&quot;,
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property(&quot;title&quot;, &amp;label, &quot;label&quot;)
</span><span class="boring">            .flags(glib::BindingFlags::SYNC_CREATE)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(@weak self as window =&gt; @default-panic, move |obj| {
</span><span class="boring">                let task_object = obj
</span><span class="boring">                    .downcast_ref()
</span><span class="boring">                    .expect(&quot;The object should be of type `TaskObject`.&quot;);
</span><span class="boring">                let row = window.create_task_row(task_object);
</span><span class="boring">                row.upcast()
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(
</span><span class="boring">            clone!(@weak self as window =&gt; move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property(&quot;completed&quot;, &amp;check_button, &quot;active&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE | BindingFlags::BIDIRECTIONAL)
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property(&quot;content&quot;, &amp;row, &quot;title&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp()
</span><span class="boring">            .entry
</span><span class="boring">            .connect_activate(clone!(@weak self as window =&gt; move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_,_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key &quot;filter&quot; changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some(&quot;filter&quot;),
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, _| {
</span><span class="boring">                window.set_filter();
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window.collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect(&quot;There needs to be an object at this position.&quot;)
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect(&quot;The object needs to be a `CollectionObject`.&quot;);
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().leaflet.navigate(NavigationDirection::Forward);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback for folding the leaflet
</span><span class="boring">        self.imp().leaflet.connect_folded_notify(
</span><span class="boring">            clone!(@weak self as window =&gt; move |leaflet| {
</span><span class="boring">                if leaflet.is_folded() {
</span><span class="boring">                    window
</span><span class="boring">                        .imp()
</span><span class="boring">                        .collections_list
</span><span class="boring">                        .set_selection_mode(SelectionMode::None)
</span><span class="boring">                } else {
</span><span class="boring">                    window
</span><span class="boring">                        .imp()
</span><span class="boring">                        .collections_list
</span><span class="boring">                        .set_selection_mode(SelectionMode::Single);
</span><span class="boring">                    window.select_collection_row();
</span><span class="boring">                }
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        self.imp().back_button.connect_clicked(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_| {
</span><span class="boring">                window.imp().leaflet.navigate(NavigationDirection::Back);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name(&quot;main&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name(&quot;placeholder&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text(&quot;&quot;);
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key &quot;filter&quot; and add to action group &quot;win&quot;
</span><span class="boring">        let action_filter = self.settings().create_action(&quot;filter&quot;);
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group &quot;win&quot;
</span><span class="boring">        let action_remove_done_tasks =
</span><span class="boring">            gio::SimpleAction::new(&quot;remove-done-tasks&quot;, None);
</span><span class="boring">        action_remove_done_tasks.connect_activate(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, _| {
</span><span class="boring">                let tasks = window.tasks();
</span><span class="boring">                let mut position = 0;
</span><span class="boring">                while let Some(item) = tasks.item(position) {
</span><span class="boring">                    // Get `TaskObject` from `glib::Object`
</span><span class="boring">                    let task_object = item
</span><span class="boring">                        .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                        .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">                    if task_object.is_completed() {
</span><span class="boring">                        tasks.remove(position);
</span><span class="boring">                    } else {
</span><span class="boring">                        position += 1;
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">        self.add_action(&amp;action_remove_done_tasks);
</span><span class="boring">
</span><span class="boring">        // Create action to create new collection and add to action group &quot;win&quot;
</span><span class="boring">        let action_new_list = gio::SimpleAction::new(&quot;new-collection&quot;, None);
</span><span class="boring">        action_new_list.connect_activate(clone!(@weak self as window =&gt; move |_, _| {
</span><span class="boring">            window.new_collection();
</span><span class="boring">        }));
</span><span class="boring">        self.add_action(&amp;action_new_list);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_collection(&amp;self) {
</span><span class="boring">        // Create new Dialog
</span><span class="boring">        let dialog = Dialog::with_buttons(
</span><span class="boring">            Some(&quot;New Collection&quot;),
</span><span class="boring">            Some(self),
</span><span class="boring">            DialogFlags::MODAL
</span><span class="boring">                | DialogFlags::DESTROY_WITH_PARENT
</span><span class="boring">                | DialogFlags::USE_HEADER_BAR,
</span><span class="boring">            &amp;[
</span><span class="boring">                (&quot;Cancel&quot;, ResponseType::Cancel),
</span><span class="boring">                (&quot;Create&quot;, ResponseType::Accept),
</span><span class="boring">            ],
</span><span class="boring">        );
</span><span class="boring">        dialog.set_default_response(ResponseType::Accept);
</span><span class="boring">
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        let dialog_button = dialog
</span><span class="boring">            .widget_for_response(ResponseType::Accept)
</span><span class="boring">            .expect(&quot;The dialog needs to have a widget for response type `Accept`.&quot;);
</span><span class="boring">        dialog_button.set_sensitive(false);
</span><span class="boring">
</span><span class="boring">        // Create entry and add it to the dialog
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .margin_top(12)
</span><span class="boring">            .margin_bottom(12)
</span><span class="boring">            .margin_start(12)
</span><span class="boring">            .margin_end(12)
</span><span class="boring">            .placeholder_text(&quot;Name&quot;)
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">        dialog.content_area().append(&amp;entry);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to &quot;error&quot;, when there is not text in it
</span><span class="boring">        entry.connect_changed(clone!(@weak dialog =&gt; move |entry| {
</span><span class="boring">            let text = entry.text();
</span><span class="boring">            let dialog_button = dialog.
</span><span class="boring">                widget_for_response(ResponseType::Accept).
</span><span class="boring">                expect(&quot;The dialog needs to have a widget for response type `Accept`.&quot;);
</span><span class="boring">            let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">            dialog_button.set_sensitive(!empty);
</span><span class="boring">
</span><span class="boring">            if empty {
</span><span class="boring">                entry.add_css_class(&quot;error&quot;);
</span><span class="boring">            } else {
</span><span class="boring">                entry.remove_css_class(&quot;error&quot;);
</span><span class="boring">            }
</span><span class="boring">        }));
</span><span class="boring">
</span><span class="boring">        // Connect response to dialog
</span><span class="boring">        dialog.connect_response(
</span><span class="boring">            clone!(@weak self as window, @weak entry =&gt; move |dialog, response| {
</span><span class="boring">                // Destroy dialog
</span><span class="boring">                dialog.destroy();
</span><span class="boring">
</span><span class="boring">                // Return if the user chose a response different than `Accept`
</span><span class="boring">                if response != ResponseType::Accept {
</span><span class="boring">                    return;
</span><span class="boring">                }
</span><span class="boring">
</span><span class="boring">                // Create a new list store
</span><span class="boring">                let tasks = gio::ListStore::new(TaskObject::static_type());
</span><span class="boring">
</span><span class="boring">                // Create a new collection object from the title the user provided
</span><span class="boring">                let title = entry.text().to_string();
</span><span class="boring">                let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">                // Add new collection object and set current tasks
</span><span class="boring">                window.collections().append(&amp;collection);
</span><span class="boring">                window.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">                // Let the leaflet navigate to the next child
</span><span class="boring">                window.imp().leaflet.navigate(NavigationDirection::Forward);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">        dialog.present();
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>As always, we want our data to be saved when we close the window.
Since most of the implementation is in the method <code>CollectionObject::to_collection_data</code>, the implementation of <code>close_request</code> doesn't change much.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::Leaflet;
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::signal::Inhibit;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::glib::SignalHandlerId;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Button, CompositeTemplate, Entry, FilterListModel, ListBox, Stack,
</span><span class="boring">};
</span><span class="boring">use once_cell::sync::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = &quot;/org/gtk_rs/Todo8/window.ui&quot;)]
</span><span class="boring">pub struct Window {
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    // 👇 all members below are new
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub collections_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub leaflet: TemplateChild&lt;Leaflet&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub stack: TemplateChild&lt;Stack&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub back_button: TemplateChild&lt;Button&gt;,
</span><span class="boring">    pub collections: OnceCell&lt;gio::ListStore&gt;,
</span><span class="boring">    pub current_collection: RefCell&lt;Option&lt;CollectionObject&gt;&gt;,
</span><span class="boring">    pub current_filter_model: RefCell&lt;Option&lt;FilterListModel&gt;&gt;,
</span><span class="boring">    pub tasks_changed_handler_id: RefCell&lt;Option&lt;SignalHandlerId&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = &quot;TodoWindow&quot;;
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = adw::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call &quot;constructed&quot; on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_collections();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span>// Trait shared by all windows
impl WindowImpl for Window {
    fn close_request(&amp;self) -&gt; Inhibit {
        // Store task data in vector
        let backup_data: Vec&lt;CollectionData&gt; = self
            .obj()
            .collections()
            .snapshot()
            .iter()
            .filter_map(Cast::downcast_ref::&lt;CollectionObject&gt;)
            .map(CollectionObject::to_collection_data)
            .collect();

        // Save state to file
        let file = File::create(data_path()).expect(&quot;Could not create json file.&quot;);
        serde_json::to_writer(file, &amp;backup_data)
            .expect(&quot;Could not write data to json file&quot;);

        // Pass close request on to the parent
        self.parent_close_request()
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all adwaita application windows
</span><span class="boring">impl AdwApplicationWindowImpl for Window {}</span></code></pre>
<p><code>constructed</code> stays mostly the same as well.
Instead of <code>setup_tasks</code> we now call <code>setup_collections</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/7/window/imp.rs">listings/todo/8/window/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::Leaflet;
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::signal::Inhibit;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::glib::SignalHandlerId;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Button, CompositeTemplate, Entry, FilterListModel, ListBox, Stack,
</span><span class="boring">};
</span><span class="boring">use once_cell::sync::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = &quot;/org/gtk_rs/Todo8/window.ui&quot;)]
</span><span class="boring">pub struct Window {
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    // 👇 all members below are new
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub collections_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub leaflet: TemplateChild&lt;Leaflet&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub stack: TemplateChild&lt;Stack&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub back_button: TemplateChild&lt;Button&gt;,
</span><span class="boring">    pub collections: OnceCell&lt;gio::ListStore&gt;,
</span><span class="boring">    pub current_collection: RefCell&lt;Option&lt;CollectionObject&gt;&gt;,
</span><span class="boring">    pub current_filter_model: RefCell&lt;Option&lt;FilterListModel&gt;&gt;,
</span><span class="boring">    pub tasks_changed_handler_id: RefCell&lt;Option&lt;SignalHandlerId&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = &quot;TodoWindow&quot;;
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = adw::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
impl ObjectImpl for Window {
    fn constructed(&amp;self) {
        // Call &quot;constructed&quot; on parent
        self.parent_constructed();

        // Setup
        let obj = self.obj();
        obj.setup_settings();
        obj.setup_collections();
        obj.restore_data();
        obj.setup_callbacks();
        obj.setup_actions();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; Inhibit {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;CollectionData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .collections()
</span><span class="boring">            .snapshot()
</span><span class="boring">            .iter()
</span><span class="boring">            .filter_map(Cast::downcast_ref::&lt;CollectionObject&gt;)
</span><span class="boring">            .map(CollectionObject::to_collection_data)
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect(&quot;Could not create json file.&quot;);
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect(&quot;Could not write data to json file&quot;);
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all adwaita application windows
</span><span class="boring">impl AdwApplicationWindowImpl for Window {}</span></code></pre>
<p><code>setup_collections</code> sets up the <code>collections</code> list store as well as assuring that changes in the model will be reflected in the <code>collections_list</code>.
To do that it uses the method <code>create_collection_row</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, NavigationDirection};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::glib::BindingFlags;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Dialog, DialogFlags, Entry,
</span><span class="boring">    FilterListModel, Label, ListBoxRow, NoSelection, ResponseType, SelectionMode,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property(&quot;application&quot;, app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect(&quot;`settings` should not be set before calling `setup_settings`.&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect(&quot;`settings` should be set in `setup_settings`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect(&quot;`current_collection` should be set in `set_current_collections`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect(&quot;`collections` should be set in `setup_collections`.&quot;)
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect(&quot;`current_filter_model` should be set in `set_current_collection`.&quot;)
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get(&quot;filter&quot;);
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            &quot;All&quot; =&gt; None,
</span><span class="boring">            &quot;Open&quot; =&gt; Some(filter_open),
</span><span class="boring">            &quot;Done&quot; =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    fn setup_collections(&amp;self) {
        let collections = gio::ListStore::new(CollectionObject::static_type());
        self.imp()
            .collections
            .set(collections.clone())
            .expect(&quot;Could not set collections&quot;);

        self.imp().collections_list.bind_model(
            Some(&amp;collections),
            clone!(@weak self as window =&gt; @default-panic, move |obj| {
                let collection_object = obj
                    .downcast_ref()
                    .expect(&quot;The object should be of type `CollectionObject`.&quot;);
                let row = window.create_collection_row(collection_object);
                row.upcast()
            }),
        )
    }
<span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    &quot;It should be possible to read `backup_data` from the json file.&quot;,
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property(&quot;title&quot;, &amp;label, &quot;label&quot;)
</span><span class="boring">            .flags(glib::BindingFlags::SYNC_CREATE)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(@weak self as window =&gt; @default-panic, move |obj| {
</span><span class="boring">                let task_object = obj
</span><span class="boring">                    .downcast_ref()
</span><span class="boring">                    .expect(&quot;The object should be of type `TaskObject`.&quot;);
</span><span class="boring">                let row = window.create_task_row(task_object);
</span><span class="boring">                row.upcast()
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(
</span><span class="boring">            clone!(@weak self as window =&gt; move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property(&quot;completed&quot;, &amp;check_button, &quot;active&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE | BindingFlags::BIDIRECTIONAL)
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property(&quot;content&quot;, &amp;row, &quot;title&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp()
</span><span class="boring">            .entry
</span><span class="boring">            .connect_activate(clone!(@weak self as window =&gt; move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_,_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key &quot;filter&quot; changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some(&quot;filter&quot;),
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, _| {
</span><span class="boring">                window.set_filter();
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window.collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect(&quot;There needs to be an object at this position.&quot;)
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect(&quot;The object needs to be a `CollectionObject`.&quot;);
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().leaflet.navigate(NavigationDirection::Forward);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback for folding the leaflet
</span><span class="boring">        self.imp().leaflet.connect_folded_notify(
</span><span class="boring">            clone!(@weak self as window =&gt; move |leaflet| {
</span><span class="boring">                if leaflet.is_folded() {
</span><span class="boring">                    window
</span><span class="boring">                        .imp()
</span><span class="boring">                        .collections_list
</span><span class="boring">                        .set_selection_mode(SelectionMode::None)
</span><span class="boring">                } else {
</span><span class="boring">                    window
</span><span class="boring">                        .imp()
</span><span class="boring">                        .collections_list
</span><span class="boring">                        .set_selection_mode(SelectionMode::Single);
</span><span class="boring">                    window.select_collection_row();
</span><span class="boring">                }
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        self.imp().back_button.connect_clicked(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_| {
</span><span class="boring">                window.imp().leaflet.navigate(NavigationDirection::Back);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name(&quot;main&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name(&quot;placeholder&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text(&quot;&quot;);
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key &quot;filter&quot; and add to action group &quot;win&quot;
</span><span class="boring">        let action_filter = self.settings().create_action(&quot;filter&quot;);
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group &quot;win&quot;
</span><span class="boring">        let action_remove_done_tasks =
</span><span class="boring">            gio::SimpleAction::new(&quot;remove-done-tasks&quot;, None);
</span><span class="boring">        action_remove_done_tasks.connect_activate(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, _| {
</span><span class="boring">                let tasks = window.tasks();
</span><span class="boring">                let mut position = 0;
</span><span class="boring">                while let Some(item) = tasks.item(position) {
</span><span class="boring">                    // Get `TaskObject` from `glib::Object`
</span><span class="boring">                    let task_object = item
</span><span class="boring">                        .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                        .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">                    if task_object.is_completed() {
</span><span class="boring">                        tasks.remove(position);
</span><span class="boring">                    } else {
</span><span class="boring">                        position += 1;
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">        self.add_action(&amp;action_remove_done_tasks);
</span><span class="boring">
</span><span class="boring">        // Create action to create new collection and add to action group &quot;win&quot;
</span><span class="boring">        let action_new_list = gio::SimpleAction::new(&quot;new-collection&quot;, None);
</span><span class="boring">        action_new_list.connect_activate(clone!(@weak self as window =&gt; move |_, _| {
</span><span class="boring">            window.new_collection();
</span><span class="boring">        }));
</span><span class="boring">        self.add_action(&amp;action_new_list);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_collection(&amp;self) {
</span><span class="boring">        // Create new Dialog
</span><span class="boring">        let dialog = Dialog::with_buttons(
</span><span class="boring">            Some(&quot;New Collection&quot;),
</span><span class="boring">            Some(self),
</span><span class="boring">            DialogFlags::MODAL
</span><span class="boring">                | DialogFlags::DESTROY_WITH_PARENT
</span><span class="boring">                | DialogFlags::USE_HEADER_BAR,
</span><span class="boring">            &amp;[
</span><span class="boring">                (&quot;Cancel&quot;, ResponseType::Cancel),
</span><span class="boring">                (&quot;Create&quot;, ResponseType::Accept),
</span><span class="boring">            ],
</span><span class="boring">        );
</span><span class="boring">        dialog.set_default_response(ResponseType::Accept);
</span><span class="boring">
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        let dialog_button = dialog
</span><span class="boring">            .widget_for_response(ResponseType::Accept)
</span><span class="boring">            .expect(&quot;The dialog needs to have a widget for response type `Accept`.&quot;);
</span><span class="boring">        dialog_button.set_sensitive(false);
</span><span class="boring">
</span><span class="boring">        // Create entry and add it to the dialog
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .margin_top(12)
</span><span class="boring">            .margin_bottom(12)
</span><span class="boring">            .margin_start(12)
</span><span class="boring">            .margin_end(12)
</span><span class="boring">            .placeholder_text(&quot;Name&quot;)
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">        dialog.content_area().append(&amp;entry);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to &quot;error&quot;, when there is not text in it
</span><span class="boring">        entry.connect_changed(clone!(@weak dialog =&gt; move |entry| {
</span><span class="boring">            let text = entry.text();
</span><span class="boring">            let dialog_button = dialog.
</span><span class="boring">                widget_for_response(ResponseType::Accept).
</span><span class="boring">                expect(&quot;The dialog needs to have a widget for response type `Accept`.&quot;);
</span><span class="boring">            let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">            dialog_button.set_sensitive(!empty);
</span><span class="boring">
</span><span class="boring">            if empty {
</span><span class="boring">                entry.add_css_class(&quot;error&quot;);
</span><span class="boring">            } else {
</span><span class="boring">                entry.remove_css_class(&quot;error&quot;);
</span><span class="boring">            }
</span><span class="boring">        }));
</span><span class="boring">
</span><span class="boring">        // Connect response to dialog
</span><span class="boring">        dialog.connect_response(
</span><span class="boring">            clone!(@weak self as window, @weak entry =&gt; move |dialog, response| {
</span><span class="boring">                // Destroy dialog
</span><span class="boring">                dialog.destroy();
</span><span class="boring">
</span><span class="boring">                // Return if the user chose a response different than `Accept`
</span><span class="boring">                if response != ResponseType::Accept {
</span><span class="boring">                    return;
</span><span class="boring">                }
</span><span class="boring">
</span><span class="boring">                // Create a new list store
</span><span class="boring">                let tasks = gio::ListStore::new(TaskObject::static_type());
</span><span class="boring">
</span><span class="boring">                // Create a new collection object from the title the user provided
</span><span class="boring">                let title = entry.text().to_string();
</span><span class="boring">                let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">                // Add new collection object and set current tasks
</span><span class="boring">                window.collections().append(&amp;collection);
</span><span class="boring">                window.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">                // Let the leaflet navigate to the next child
</span><span class="boring">                window.imp().leaflet.navigate(NavigationDirection::Forward);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">        dialog.present();
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><code>create_collection_row</code> takes a <code>CollectionObject</code> and builds a <a href="../docs/gtk4/struct.ListBoxRow.html"><code>gtk::ListBoxRow</code></a> from its information.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, NavigationDirection};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::glib::BindingFlags;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Dialog, DialogFlags, Entry,
</span><span class="boring">    FilterListModel, Label, ListBoxRow, NoSelection, ResponseType, SelectionMode,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property(&quot;application&quot;, app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect(&quot;`settings` should not be set before calling `setup_settings`.&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect(&quot;`settings` should be set in `setup_settings`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect(&quot;`current_collection` should be set in `set_current_collections`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect(&quot;`collections` should be set in `setup_collections`.&quot;)
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect(&quot;`current_filter_model` should be set in `set_current_collection`.&quot;)
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get(&quot;filter&quot;);
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            &quot;All&quot; =&gt; None,
</span><span class="boring">            &quot;Open&quot; =&gt; Some(filter_open),
</span><span class="boring">            &quot;Done&quot; =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new(CollectionObject::static_type());
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect(&quot;Could not set collections&quot;);
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(@weak self as window =&gt; @default-panic, move |obj| {
</span><span class="boring">                let collection_object = obj
</span><span class="boring">                    .downcast_ref()
</span><span class="boring">                    .expect(&quot;The object should be of type `CollectionObject`.&quot;);
</span><span class="boring">                let row = window.create_collection_row(collection_object);
</span><span class="boring">                row.upcast()
</span><span class="boring">            }),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    &quot;It should be possible to read `backup_data` from the json file.&quot;,
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    fn create_collection_row(
        &amp;self,
        collection_object: &amp;CollectionObject,
    ) -&gt; ListBoxRow {
        let label = Label::builder()
            .ellipsize(pango::EllipsizeMode::End)
            .xalign(0.0)
            .build();

        collection_object
            .bind_property(&quot;title&quot;, &amp;label, &quot;label&quot;)
            .flags(glib::BindingFlags::SYNC_CREATE)
            .build();

        ListBoxRow::builder().child(&amp;label).build()
    }
<span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(@weak self as window =&gt; @default-panic, move |obj| {
</span><span class="boring">                let task_object = obj
</span><span class="boring">                    .downcast_ref()
</span><span class="boring">                    .expect(&quot;The object should be of type `TaskObject`.&quot;);
</span><span class="boring">                let row = window.create_task_row(task_object);
</span><span class="boring">                row.upcast()
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(
</span><span class="boring">            clone!(@weak self as window =&gt; move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property(&quot;completed&quot;, &amp;check_button, &quot;active&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE | BindingFlags::BIDIRECTIONAL)
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property(&quot;content&quot;, &amp;row, &quot;title&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp()
</span><span class="boring">            .entry
</span><span class="boring">            .connect_activate(clone!(@weak self as window =&gt; move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_,_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key &quot;filter&quot; changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some(&quot;filter&quot;),
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, _| {
</span><span class="boring">                window.set_filter();
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window.collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect(&quot;There needs to be an object at this position.&quot;)
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect(&quot;The object needs to be a `CollectionObject`.&quot;);
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().leaflet.navigate(NavigationDirection::Forward);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback for folding the leaflet
</span><span class="boring">        self.imp().leaflet.connect_folded_notify(
</span><span class="boring">            clone!(@weak self as window =&gt; move |leaflet| {
</span><span class="boring">                if leaflet.is_folded() {
</span><span class="boring">                    window
</span><span class="boring">                        .imp()
</span><span class="boring">                        .collections_list
</span><span class="boring">                        .set_selection_mode(SelectionMode::None)
</span><span class="boring">                } else {
</span><span class="boring">                    window
</span><span class="boring">                        .imp()
</span><span class="boring">                        .collections_list
</span><span class="boring">                        .set_selection_mode(SelectionMode::Single);
</span><span class="boring">                    window.select_collection_row();
</span><span class="boring">                }
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        self.imp().back_button.connect_clicked(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_| {
</span><span class="boring">                window.imp().leaflet.navigate(NavigationDirection::Back);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name(&quot;main&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name(&quot;placeholder&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text(&quot;&quot;);
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key &quot;filter&quot; and add to action group &quot;win&quot;
</span><span class="boring">        let action_filter = self.settings().create_action(&quot;filter&quot;);
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group &quot;win&quot;
</span><span class="boring">        let action_remove_done_tasks =
</span><span class="boring">            gio::SimpleAction::new(&quot;remove-done-tasks&quot;, None);
</span><span class="boring">        action_remove_done_tasks.connect_activate(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, _| {
</span><span class="boring">                let tasks = window.tasks();
</span><span class="boring">                let mut position = 0;
</span><span class="boring">                while let Some(item) = tasks.item(position) {
</span><span class="boring">                    // Get `TaskObject` from `glib::Object`
</span><span class="boring">                    let task_object = item
</span><span class="boring">                        .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                        .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">                    if task_object.is_completed() {
</span><span class="boring">                        tasks.remove(position);
</span><span class="boring">                    } else {
</span><span class="boring">                        position += 1;
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">        self.add_action(&amp;action_remove_done_tasks);
</span><span class="boring">
</span><span class="boring">        // Create action to create new collection and add to action group &quot;win&quot;
</span><span class="boring">        let action_new_list = gio::SimpleAction::new(&quot;new-collection&quot;, None);
</span><span class="boring">        action_new_list.connect_activate(clone!(@weak self as window =&gt; move |_, _| {
</span><span class="boring">            window.new_collection();
</span><span class="boring">        }));
</span><span class="boring">        self.add_action(&amp;action_new_list);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_collection(&amp;self) {
</span><span class="boring">        // Create new Dialog
</span><span class="boring">        let dialog = Dialog::with_buttons(
</span><span class="boring">            Some(&quot;New Collection&quot;),
</span><span class="boring">            Some(self),
</span><span class="boring">            DialogFlags::MODAL
</span><span class="boring">                | DialogFlags::DESTROY_WITH_PARENT
</span><span class="boring">                | DialogFlags::USE_HEADER_BAR,
</span><span class="boring">            &amp;[
</span><span class="boring">                (&quot;Cancel&quot;, ResponseType::Cancel),
</span><span class="boring">                (&quot;Create&quot;, ResponseType::Accept),
</span><span class="boring">            ],
</span><span class="boring">        );
</span><span class="boring">        dialog.set_default_response(ResponseType::Accept);
</span><span class="boring">
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        let dialog_button = dialog
</span><span class="boring">            .widget_for_response(ResponseType::Accept)
</span><span class="boring">            .expect(&quot;The dialog needs to have a widget for response type `Accept`.&quot;);
</span><span class="boring">        dialog_button.set_sensitive(false);
</span><span class="boring">
</span><span class="boring">        // Create entry and add it to the dialog
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .margin_top(12)
</span><span class="boring">            .margin_bottom(12)
</span><span class="boring">            .margin_start(12)
</span><span class="boring">            .margin_end(12)
</span><span class="boring">            .placeholder_text(&quot;Name&quot;)
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">        dialog.content_area().append(&amp;entry);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to &quot;error&quot;, when there is not text in it
</span><span class="boring">        entry.connect_changed(clone!(@weak dialog =&gt; move |entry| {
</span><span class="boring">            let text = entry.text();
</span><span class="boring">            let dialog_button = dialog.
</span><span class="boring">                widget_for_response(ResponseType::Accept).
</span><span class="boring">                expect(&quot;The dialog needs to have a widget for response type `Accept`.&quot;);
</span><span class="boring">            let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">            dialog_button.set_sensitive(!empty);
</span><span class="boring">
</span><span class="boring">            if empty {
</span><span class="boring">                entry.add_css_class(&quot;error&quot;);
</span><span class="boring">            } else {
</span><span class="boring">                entry.remove_css_class(&quot;error&quot;);
</span><span class="boring">            }
</span><span class="boring">        }));
</span><span class="boring">
</span><span class="boring">        // Connect response to dialog
</span><span class="boring">        dialog.connect_response(
</span><span class="boring">            clone!(@weak self as window, @weak entry =&gt; move |dialog, response| {
</span><span class="boring">                // Destroy dialog
</span><span class="boring">                dialog.destroy();
</span><span class="boring">
</span><span class="boring">                // Return if the user chose a response different than `Accept`
</span><span class="boring">                if response != ResponseType::Accept {
</span><span class="boring">                    return;
</span><span class="boring">                }
</span><span class="boring">
</span><span class="boring">                // Create a new list store
</span><span class="boring">                let tasks = gio::ListStore::new(TaskObject::static_type());
</span><span class="boring">
</span><span class="boring">                // Create a new collection object from the title the user provided
</span><span class="boring">                let title = entry.text().to_string();
</span><span class="boring">                let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">                // Add new collection object and set current tasks
</span><span class="boring">                window.collections().append(&amp;collection);
</span><span class="boring">                window.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">                // Let the leaflet navigate to the next child
</span><span class="boring">                window.imp().leaflet.navigate(NavigationDirection::Forward);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">        dialog.present();
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>We also adapt <code>restore_data</code>.
Again, the heavy lifting comes from <code>CollectionObject::from_collection_data</code>, so we don't have to change too much here.
Since the rows of <code>collections_list</code> can be selected, we have to select one of them after restoring the data.
We choose the first one and let the method <code>set_current_collection</code> do the rest.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, NavigationDirection};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::glib::BindingFlags;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Dialog, DialogFlags, Entry,
</span><span class="boring">    FilterListModel, Label, ListBoxRow, NoSelection, ResponseType, SelectionMode,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property(&quot;application&quot;, app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect(&quot;`settings` should not be set before calling `setup_settings`.&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect(&quot;`settings` should be set in `setup_settings`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect(&quot;`current_collection` should be set in `set_current_collections`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect(&quot;`collections` should be set in `setup_collections`.&quot;)
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect(&quot;`current_filter_model` should be set in `set_current_collection`.&quot;)
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get(&quot;filter&quot;);
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            &quot;All&quot; =&gt; None,
</span><span class="boring">            &quot;Open&quot; =&gt; Some(filter_open),
</span><span class="boring">            &quot;Done&quot; =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new(CollectionObject::static_type());
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect(&quot;Could not set collections&quot;);
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(@weak self as window =&gt; @default-panic, move |obj| {
</span><span class="boring">                let collection_object = obj
</span><span class="boring">                    .downcast_ref()
</span><span class="boring">                    .expect(&quot;The object should be of type `CollectionObject`.&quot;);
</span><span class="boring">                let row = window.create_collection_row(collection_object);
</span><span class="boring">                row.upcast()
</span><span class="boring">            }),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span>    fn restore_data(&amp;self) {
        if let Ok(file) = File::open(data_path()) {
            // Deserialize data from file to vector
            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
                .expect(
                    &quot;It should be possible to read `backup_data` from the json file.&quot;,
                );

            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
            let collections: Vec&lt;CollectionObject&gt; = backup_data
                .into_iter()
                .map(CollectionObject::from_collection_data)
                .collect();

            // Insert restored objects into model
            self.collections().extend_from_slice(&amp;collections);

            // Set first collection as current
            if let Some(first_collection) = collections.first() {
                self.set_current_collection(first_collection.clone());
            }
        }
    }
<span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property(&quot;title&quot;, &amp;label, &quot;label&quot;)
</span><span class="boring">            .flags(glib::BindingFlags::SYNC_CREATE)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(@weak self as window =&gt; @default-panic, move |obj| {
</span><span class="boring">                let task_object = obj
</span><span class="boring">                    .downcast_ref()
</span><span class="boring">                    .expect(&quot;The object should be of type `TaskObject`.&quot;);
</span><span class="boring">                let row = window.create_task_row(task_object);
</span><span class="boring">                row.upcast()
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(
</span><span class="boring">            clone!(@weak self as window =&gt; move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property(&quot;completed&quot;, &amp;check_button, &quot;active&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE | BindingFlags::BIDIRECTIONAL)
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property(&quot;content&quot;, &amp;row, &quot;title&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp()
</span><span class="boring">            .entry
</span><span class="boring">            .connect_activate(clone!(@weak self as window =&gt; move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_,_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key &quot;filter&quot; changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some(&quot;filter&quot;),
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, _| {
</span><span class="boring">                window.set_filter();
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window.collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect(&quot;There needs to be an object at this position.&quot;)
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect(&quot;The object needs to be a `CollectionObject`.&quot;);
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().leaflet.navigate(NavigationDirection::Forward);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback for folding the leaflet
</span><span class="boring">        self.imp().leaflet.connect_folded_notify(
</span><span class="boring">            clone!(@weak self as window =&gt; move |leaflet| {
</span><span class="boring">                if leaflet.is_folded() {
</span><span class="boring">                    window
</span><span class="boring">                        .imp()
</span><span class="boring">                        .collections_list
</span><span class="boring">                        .set_selection_mode(SelectionMode::None)
</span><span class="boring">                } else {
</span><span class="boring">                    window
</span><span class="boring">                        .imp()
</span><span class="boring">                        .collections_list
</span><span class="boring">                        .set_selection_mode(SelectionMode::Single);
</span><span class="boring">                    window.select_collection_row();
</span><span class="boring">                }
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        self.imp().back_button.connect_clicked(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_| {
</span><span class="boring">                window.imp().leaflet.navigate(NavigationDirection::Back);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name(&quot;main&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name(&quot;placeholder&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text(&quot;&quot;);
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key &quot;filter&quot; and add to action group &quot;win&quot;
</span><span class="boring">        let action_filter = self.settings().create_action(&quot;filter&quot;);
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group &quot;win&quot;
</span><span class="boring">        let action_remove_done_tasks =
</span><span class="boring">            gio::SimpleAction::new(&quot;remove-done-tasks&quot;, None);
</span><span class="boring">        action_remove_done_tasks.connect_activate(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, _| {
</span><span class="boring">                let tasks = window.tasks();
</span><span class="boring">                let mut position = 0;
</span><span class="boring">                while let Some(item) = tasks.item(position) {
</span><span class="boring">                    // Get `TaskObject` from `glib::Object`
</span><span class="boring">                    let task_object = item
</span><span class="boring">                        .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                        .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">                    if task_object.is_completed() {
</span><span class="boring">                        tasks.remove(position);
</span><span class="boring">                    } else {
</span><span class="boring">                        position += 1;
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">        self.add_action(&amp;action_remove_done_tasks);
</span><span class="boring">
</span><span class="boring">        // Create action to create new collection and add to action group &quot;win&quot;
</span><span class="boring">        let action_new_list = gio::SimpleAction::new(&quot;new-collection&quot;, None);
</span><span class="boring">        action_new_list.connect_activate(clone!(@weak self as window =&gt; move |_, _| {
</span><span class="boring">            window.new_collection();
</span><span class="boring">        }));
</span><span class="boring">        self.add_action(&amp;action_new_list);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_collection(&amp;self) {
</span><span class="boring">        // Create new Dialog
</span><span class="boring">        let dialog = Dialog::with_buttons(
</span><span class="boring">            Some(&quot;New Collection&quot;),
</span><span class="boring">            Some(self),
</span><span class="boring">            DialogFlags::MODAL
</span><span class="boring">                | DialogFlags::DESTROY_WITH_PARENT
</span><span class="boring">                | DialogFlags::USE_HEADER_BAR,
</span><span class="boring">            &amp;[
</span><span class="boring">                (&quot;Cancel&quot;, ResponseType::Cancel),
</span><span class="boring">                (&quot;Create&quot;, ResponseType::Accept),
</span><span class="boring">            ],
</span><span class="boring">        );
</span><span class="boring">        dialog.set_default_response(ResponseType::Accept);
</span><span class="boring">
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        let dialog_button = dialog
</span><span class="boring">            .widget_for_response(ResponseType::Accept)
</span><span class="boring">            .expect(&quot;The dialog needs to have a widget for response type `Accept`.&quot;);
</span><span class="boring">        dialog_button.set_sensitive(false);
</span><span class="boring">
</span><span class="boring">        // Create entry and add it to the dialog
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .margin_top(12)
</span><span class="boring">            .margin_bottom(12)
</span><span class="boring">            .margin_start(12)
</span><span class="boring">            .margin_end(12)
</span><span class="boring">            .placeholder_text(&quot;Name&quot;)
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">        dialog.content_area().append(&amp;entry);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to &quot;error&quot;, when there is not text in it
</span><span class="boring">        entry.connect_changed(clone!(@weak dialog =&gt; move |entry| {
</span><span class="boring">            let text = entry.text();
</span><span class="boring">            let dialog_button = dialog.
</span><span class="boring">                widget_for_response(ResponseType::Accept).
</span><span class="boring">                expect(&quot;The dialog needs to have a widget for response type `Accept`.&quot;);
</span><span class="boring">            let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">            dialog_button.set_sensitive(!empty);
</span><span class="boring">
</span><span class="boring">            if empty {
</span><span class="boring">                entry.add_css_class(&quot;error&quot;);
</span><span class="boring">            } else {
</span><span class="boring">                entry.remove_css_class(&quot;error&quot;);
</span><span class="boring">            }
</span><span class="boring">        }));
</span><span class="boring">
</span><span class="boring">        // Connect response to dialog
</span><span class="boring">        dialog.connect_response(
</span><span class="boring">            clone!(@weak self as window, @weak entry =&gt; move |dialog, response| {
</span><span class="boring">                // Destroy dialog
</span><span class="boring">                dialog.destroy();
</span><span class="boring">
</span><span class="boring">                // Return if the user chose a response different than `Accept`
</span><span class="boring">                if response != ResponseType::Accept {
</span><span class="boring">                    return;
</span><span class="boring">                }
</span><span class="boring">
</span><span class="boring">                // Create a new list store
</span><span class="boring">                let tasks = gio::ListStore::new(TaskObject::static_type());
</span><span class="boring">
</span><span class="boring">                // Create a new collection object from the title the user provided
</span><span class="boring">                let title = entry.text().to_string();
</span><span class="boring">                let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">                // Add new collection object and set current tasks
</span><span class="boring">                window.collections().append(&amp;collection);
</span><span class="boring">                window.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">                // Let the leaflet navigate to the next child
</span><span class="boring">                window.imp().leaflet.navigate(NavigationDirection::Forward);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">        dialog.present();
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><code>set_current_collection</code> assures that all elements accessing tasks refer to the task model of the current collection.
We bind the <code>tasks_list</code> to the current collection and store the filter model.
Whenever there are no tasks in our current collection we want to hide our tasks list.
Otherwise, the list box will leave a bad-looking line behind.
However, we don't want to accumulate signal handlers whenever we switch collections.
This is why we store the <code>tasks_changed_handler_id</code> and disconnect the old handler as soon as we set a new collection.
Finally, we select the collection row.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, NavigationDirection};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::glib::BindingFlags;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Dialog, DialogFlags, Entry,
</span><span class="boring">    FilterListModel, Label, ListBoxRow, NoSelection, ResponseType, SelectionMode,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property(&quot;application&quot;, app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect(&quot;`settings` should not be set before calling `setup_settings`.&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect(&quot;`settings` should be set in `setup_settings`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect(&quot;`current_collection` should be set in `set_current_collections`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect(&quot;`collections` should be set in `setup_collections`.&quot;)
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect(&quot;`current_filter_model` should be set in `set_current_collection`.&quot;)
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get(&quot;filter&quot;);
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            &quot;All&quot; =&gt; None,
</span><span class="boring">            &quot;Open&quot; =&gt; Some(filter_open),
</span><span class="boring">            &quot;Done&quot; =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new(CollectionObject::static_type());
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect(&quot;Could not set collections&quot;);
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(@weak self as window =&gt; @default-panic, move |obj| {
</span><span class="boring">                let collection_object = obj
</span><span class="boring">                    .downcast_ref()
</span><span class="boring">                    .expect(&quot;The object should be of type `CollectionObject`.&quot;);
</span><span class="boring">                let row = window.create_collection_row(collection_object);
</span><span class="boring">                row.upcast()
</span><span class="boring">            }),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    &quot;It should be possible to read `backup_data` from the json file.&quot;,
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property(&quot;title&quot;, &amp;label, &quot;label&quot;)
</span><span class="boring">            .flags(glib::BindingFlags::SYNC_CREATE)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span>    fn set_current_collection(&amp;self, collection: CollectionObject) {
        // Wrap model with filter and selection and pass it to the list box
        let tasks = collection.tasks();
        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
        let selection_model = NoSelection::new(Some(filter_model.clone()));
        self.imp().tasks_list.bind_model(
            Some(&amp;selection_model),
            clone!(@weak self as window =&gt; @default-panic, move |obj| {
                let task_object = obj
                    .downcast_ref()
                    .expect(&quot;The object should be of type `TaskObject`.&quot;);
                let row = window.create_task_row(task_object);
                row.upcast()
            }),
        );

        // Store filter model
        self.imp().current_filter_model.replace(Some(filter_model));

        // If present, disconnect old `tasks_changed` handler
        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
            self.tasks().disconnect(handler_id);
        }

        // Assure that the task list is only visible when it is supposed to
        self.set_task_list_visible(&amp;tasks);
        let tasks_changed_handler_id = tasks.connect_items_changed(
            clone!(@weak self as window =&gt; move |tasks, _, _, _| {
                window.set_task_list_visible(tasks);
            }),
        );
        self.imp()
            .tasks_changed_handler_id
            .replace(Some(tasks_changed_handler_id));

        // Set current tasks
        self.imp().current_collection.replace(Some(collection));

        self.select_collection_row();
    }
<span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property(&quot;completed&quot;, &amp;check_button, &quot;active&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE | BindingFlags::BIDIRECTIONAL)
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property(&quot;content&quot;, &amp;row, &quot;title&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp()
</span><span class="boring">            .entry
</span><span class="boring">            .connect_activate(clone!(@weak self as window =&gt; move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_,_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key &quot;filter&quot; changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some(&quot;filter&quot;),
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, _| {
</span><span class="boring">                window.set_filter();
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window.collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect(&quot;There needs to be an object at this position.&quot;)
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect(&quot;The object needs to be a `CollectionObject`.&quot;);
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().leaflet.navigate(NavigationDirection::Forward);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback for folding the leaflet
</span><span class="boring">        self.imp().leaflet.connect_folded_notify(
</span><span class="boring">            clone!(@weak self as window =&gt; move |leaflet| {
</span><span class="boring">                if leaflet.is_folded() {
</span><span class="boring">                    window
</span><span class="boring">                        .imp()
</span><span class="boring">                        .collections_list
</span><span class="boring">                        .set_selection_mode(SelectionMode::None)
</span><span class="boring">                } else {
</span><span class="boring">                    window
</span><span class="boring">                        .imp()
</span><span class="boring">                        .collections_list
</span><span class="boring">                        .set_selection_mode(SelectionMode::Single);
</span><span class="boring">                    window.select_collection_row();
</span><span class="boring">                }
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        self.imp().back_button.connect_clicked(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_| {
</span><span class="boring">                window.imp().leaflet.navigate(NavigationDirection::Back);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name(&quot;main&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name(&quot;placeholder&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text(&quot;&quot;);
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key &quot;filter&quot; and add to action group &quot;win&quot;
</span><span class="boring">        let action_filter = self.settings().create_action(&quot;filter&quot;);
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group &quot;win&quot;
</span><span class="boring">        let action_remove_done_tasks =
</span><span class="boring">            gio::SimpleAction::new(&quot;remove-done-tasks&quot;, None);
</span><span class="boring">        action_remove_done_tasks.connect_activate(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, _| {
</span><span class="boring">                let tasks = window.tasks();
</span><span class="boring">                let mut position = 0;
</span><span class="boring">                while let Some(item) = tasks.item(position) {
</span><span class="boring">                    // Get `TaskObject` from `glib::Object`
</span><span class="boring">                    let task_object = item
</span><span class="boring">                        .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                        .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">                    if task_object.is_completed() {
</span><span class="boring">                        tasks.remove(position);
</span><span class="boring">                    } else {
</span><span class="boring">                        position += 1;
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">        self.add_action(&amp;action_remove_done_tasks);
</span><span class="boring">
</span><span class="boring">        // Create action to create new collection and add to action group &quot;win&quot;
</span><span class="boring">        let action_new_list = gio::SimpleAction::new(&quot;new-collection&quot;, None);
</span><span class="boring">        action_new_list.connect_activate(clone!(@weak self as window =&gt; move |_, _| {
</span><span class="boring">            window.new_collection();
</span><span class="boring">        }));
</span><span class="boring">        self.add_action(&amp;action_new_list);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_collection(&amp;self) {
</span><span class="boring">        // Create new Dialog
</span><span class="boring">        let dialog = Dialog::with_buttons(
</span><span class="boring">            Some(&quot;New Collection&quot;),
</span><span class="boring">            Some(self),
</span><span class="boring">            DialogFlags::MODAL
</span><span class="boring">                | DialogFlags::DESTROY_WITH_PARENT
</span><span class="boring">                | DialogFlags::USE_HEADER_BAR,
</span><span class="boring">            &amp;[
</span><span class="boring">                (&quot;Cancel&quot;, ResponseType::Cancel),
</span><span class="boring">                (&quot;Create&quot;, ResponseType::Accept),
</span><span class="boring">            ],
</span><span class="boring">        );
</span><span class="boring">        dialog.set_default_response(ResponseType::Accept);
</span><span class="boring">
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        let dialog_button = dialog
</span><span class="boring">            .widget_for_response(ResponseType::Accept)
</span><span class="boring">            .expect(&quot;The dialog needs to have a widget for response type `Accept`.&quot;);
</span><span class="boring">        dialog_button.set_sensitive(false);
</span><span class="boring">
</span><span class="boring">        // Create entry and add it to the dialog
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .margin_top(12)
</span><span class="boring">            .margin_bottom(12)
</span><span class="boring">            .margin_start(12)
</span><span class="boring">            .margin_end(12)
</span><span class="boring">            .placeholder_text(&quot;Name&quot;)
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">        dialog.content_area().append(&amp;entry);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to &quot;error&quot;, when there is not text in it
</span><span class="boring">        entry.connect_changed(clone!(@weak dialog =&gt; move |entry| {
</span><span class="boring">            let text = entry.text();
</span><span class="boring">            let dialog_button = dialog.
</span><span class="boring">                widget_for_response(ResponseType::Accept).
</span><span class="boring">                expect(&quot;The dialog needs to have a widget for response type `Accept`.&quot;);
</span><span class="boring">            let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">            dialog_button.set_sensitive(!empty);
</span><span class="boring">
</span><span class="boring">            if empty {
</span><span class="boring">                entry.add_css_class(&quot;error&quot;);
</span><span class="boring">            } else {
</span><span class="boring">                entry.remove_css_class(&quot;error&quot;);
</span><span class="boring">            }
</span><span class="boring">        }));
</span><span class="boring">
</span><span class="boring">        // Connect response to dialog
</span><span class="boring">        dialog.connect_response(
</span><span class="boring">            clone!(@weak self as window, @weak entry =&gt; move |dialog, response| {
</span><span class="boring">                // Destroy dialog
</span><span class="boring">                dialog.destroy();
</span><span class="boring">
</span><span class="boring">                // Return if the user chose a response different than `Accept`
</span><span class="boring">                if response != ResponseType::Accept {
</span><span class="boring">                    return;
</span><span class="boring">                }
</span><span class="boring">
</span><span class="boring">                // Create a new list store
</span><span class="boring">                let tasks = gio::ListStore::new(TaskObject::static_type());
</span><span class="boring">
</span><span class="boring">                // Create a new collection object from the title the user provided
</span><span class="boring">                let title = entry.text().to_string();
</span><span class="boring">                let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">                // Add new collection object and set current tasks
</span><span class="boring">                window.collections().append(&amp;collection);
</span><span class="boring">                window.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">                // Let the leaflet navigate to the next child
</span><span class="boring">                window.imp().leaflet.navigate(NavigationDirection::Forward);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">        dialog.present();
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Previously, we used the method <code>set_task_list_visible</code>.
It assures that <code>tasks_list</code> is only visible if the number of tasks is greater than 0.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, NavigationDirection};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::glib::BindingFlags;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Dialog, DialogFlags, Entry,
</span><span class="boring">    FilterListModel, Label, ListBoxRow, NoSelection, ResponseType, SelectionMode,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property(&quot;application&quot;, app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect(&quot;`settings` should not be set before calling `setup_settings`.&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect(&quot;`settings` should be set in `setup_settings`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect(&quot;`current_collection` should be set in `set_current_collections`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect(&quot;`collections` should be set in `setup_collections`.&quot;)
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect(&quot;`current_filter_model` should be set in `set_current_collection`.&quot;)
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get(&quot;filter&quot;);
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            &quot;All&quot; =&gt; None,
</span><span class="boring">            &quot;Open&quot; =&gt; Some(filter_open),
</span><span class="boring">            &quot;Done&quot; =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new(CollectionObject::static_type());
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect(&quot;Could not set collections&quot;);
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(@weak self as window =&gt; @default-panic, move |obj| {
</span><span class="boring">                let collection_object = obj
</span><span class="boring">                    .downcast_ref()
</span><span class="boring">                    .expect(&quot;The object should be of type `CollectionObject`.&quot;);
</span><span class="boring">                let row = window.create_collection_row(collection_object);
</span><span class="boring">                row.upcast()
</span><span class="boring">            }),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    &quot;It should be possible to read `backup_data` from the json file.&quot;,
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property(&quot;title&quot;, &amp;label, &quot;label&quot;)
</span><span class="boring">            .flags(glib::BindingFlags::SYNC_CREATE)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(@weak self as window =&gt; @default-panic, move |obj| {
</span><span class="boring">                let task_object = obj
</span><span class="boring">                    .downcast_ref()
</span><span class="boring">                    .expect(&quot;The object should be of type `TaskObject`.&quot;);
</span><span class="boring">                let row = window.create_task_row(task_object);
</span><span class="boring">                row.upcast()
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(
</span><span class="boring">            clone!(@weak self as window =&gt; move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span>    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
    }
<span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property(&quot;completed&quot;, &amp;check_button, &quot;active&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE | BindingFlags::BIDIRECTIONAL)
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property(&quot;content&quot;, &amp;row, &quot;title&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp()
</span><span class="boring">            .entry
</span><span class="boring">            .connect_activate(clone!(@weak self as window =&gt; move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_,_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key &quot;filter&quot; changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some(&quot;filter&quot;),
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, _| {
</span><span class="boring">                window.set_filter();
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window.collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect(&quot;There needs to be an object at this position.&quot;)
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect(&quot;The object needs to be a `CollectionObject`.&quot;);
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().leaflet.navigate(NavigationDirection::Forward);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback for folding the leaflet
</span><span class="boring">        self.imp().leaflet.connect_folded_notify(
</span><span class="boring">            clone!(@weak self as window =&gt; move |leaflet| {
</span><span class="boring">                if leaflet.is_folded() {
</span><span class="boring">                    window
</span><span class="boring">                        .imp()
</span><span class="boring">                        .collections_list
</span><span class="boring">                        .set_selection_mode(SelectionMode::None)
</span><span class="boring">                } else {
</span><span class="boring">                    window
</span><span class="boring">                        .imp()
</span><span class="boring">                        .collections_list
</span><span class="boring">                        .set_selection_mode(SelectionMode::Single);
</span><span class="boring">                    window.select_collection_row();
</span><span class="boring">                }
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        self.imp().back_button.connect_clicked(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_| {
</span><span class="boring">                window.imp().leaflet.navigate(NavigationDirection::Back);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name(&quot;main&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name(&quot;placeholder&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text(&quot;&quot;);
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key &quot;filter&quot; and add to action group &quot;win&quot;
</span><span class="boring">        let action_filter = self.settings().create_action(&quot;filter&quot;);
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group &quot;win&quot;
</span><span class="boring">        let action_remove_done_tasks =
</span><span class="boring">            gio::SimpleAction::new(&quot;remove-done-tasks&quot;, None);
</span><span class="boring">        action_remove_done_tasks.connect_activate(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, _| {
</span><span class="boring">                let tasks = window.tasks();
</span><span class="boring">                let mut position = 0;
</span><span class="boring">                while let Some(item) = tasks.item(position) {
</span><span class="boring">                    // Get `TaskObject` from `glib::Object`
</span><span class="boring">                    let task_object = item
</span><span class="boring">                        .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                        .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">                    if task_object.is_completed() {
</span><span class="boring">                        tasks.remove(position);
</span><span class="boring">                    } else {
</span><span class="boring">                        position += 1;
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">        self.add_action(&amp;action_remove_done_tasks);
</span><span class="boring">
</span><span class="boring">        // Create action to create new collection and add to action group &quot;win&quot;
</span><span class="boring">        let action_new_list = gio::SimpleAction::new(&quot;new-collection&quot;, None);
</span><span class="boring">        action_new_list.connect_activate(clone!(@weak self as window =&gt; move |_, _| {
</span><span class="boring">            window.new_collection();
</span><span class="boring">        }));
</span><span class="boring">        self.add_action(&amp;action_new_list);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_collection(&amp;self) {
</span><span class="boring">        // Create new Dialog
</span><span class="boring">        let dialog = Dialog::with_buttons(
</span><span class="boring">            Some(&quot;New Collection&quot;),
</span><span class="boring">            Some(self),
</span><span class="boring">            DialogFlags::MODAL
</span><span class="boring">                | DialogFlags::DESTROY_WITH_PARENT
</span><span class="boring">                | DialogFlags::USE_HEADER_BAR,
</span><span class="boring">            &amp;[
</span><span class="boring">                (&quot;Cancel&quot;, ResponseType::Cancel),
</span><span class="boring">                (&quot;Create&quot;, ResponseType::Accept),
</span><span class="boring">            ],
</span><span class="boring">        );
</span><span class="boring">        dialog.set_default_response(ResponseType::Accept);
</span><span class="boring">
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        let dialog_button = dialog
</span><span class="boring">            .widget_for_response(ResponseType::Accept)
</span><span class="boring">            .expect(&quot;The dialog needs to have a widget for response type `Accept`.&quot;);
</span><span class="boring">        dialog_button.set_sensitive(false);
</span><span class="boring">
</span><span class="boring">        // Create entry and add it to the dialog
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .margin_top(12)
</span><span class="boring">            .margin_bottom(12)
</span><span class="boring">            .margin_start(12)
</span><span class="boring">            .margin_end(12)
</span><span class="boring">            .placeholder_text(&quot;Name&quot;)
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">        dialog.content_area().append(&amp;entry);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to &quot;error&quot;, when there is not text in it
</span><span class="boring">        entry.connect_changed(clone!(@weak dialog =&gt; move |entry| {
</span><span class="boring">            let text = entry.text();
</span><span class="boring">            let dialog_button = dialog.
</span><span class="boring">                widget_for_response(ResponseType::Accept).
</span><span class="boring">                expect(&quot;The dialog needs to have a widget for response type `Accept`.&quot;);
</span><span class="boring">            let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">            dialog_button.set_sensitive(!empty);
</span><span class="boring">
</span><span class="boring">            if empty {
</span><span class="boring">                entry.add_css_class(&quot;error&quot;);
</span><span class="boring">            } else {
</span><span class="boring">                entry.remove_css_class(&quot;error&quot;);
</span><span class="boring">            }
</span><span class="boring">        }));
</span><span class="boring">
</span><span class="boring">        // Connect response to dialog
</span><span class="boring">        dialog.connect_response(
</span><span class="boring">            clone!(@weak self as window, @weak entry =&gt; move |dialog, response| {
</span><span class="boring">                // Destroy dialog
</span><span class="boring">                dialog.destroy();
</span><span class="boring">
</span><span class="boring">                // Return if the user chose a response different than `Accept`
</span><span class="boring">                if response != ResponseType::Accept {
</span><span class="boring">                    return;
</span><span class="boring">                }
</span><span class="boring">
</span><span class="boring">                // Create a new list store
</span><span class="boring">                let tasks = gio::ListStore::new(TaskObject::static_type());
</span><span class="boring">
</span><span class="boring">                // Create a new collection object from the title the user provided
</span><span class="boring">                let title = entry.text().to_string();
</span><span class="boring">                let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">                // Add new collection object and set current tasks
</span><span class="boring">                window.collections().append(&amp;collection);
</span><span class="boring">                window.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">                // Let the leaflet navigate to the next child
</span><span class="boring">                window.imp().leaflet.navigate(NavigationDirection::Forward);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">        dialog.present();
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><code>select_collection_row</code> assures that the row for the current collection is selected in <code>collections_list</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, NavigationDirection};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::glib::BindingFlags;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Dialog, DialogFlags, Entry,
</span><span class="boring">    FilterListModel, Label, ListBoxRow, NoSelection, ResponseType, SelectionMode,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property(&quot;application&quot;, app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect(&quot;`settings` should not be set before calling `setup_settings`.&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect(&quot;`settings` should be set in `setup_settings`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect(&quot;`current_collection` should be set in `set_current_collections`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect(&quot;`collections` should be set in `setup_collections`.&quot;)
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect(&quot;`current_filter_model` should be set in `set_current_collection`.&quot;)
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get(&quot;filter&quot;);
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            &quot;All&quot; =&gt; None,
</span><span class="boring">            &quot;Open&quot; =&gt; Some(filter_open),
</span><span class="boring">            &quot;Done&quot; =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new(CollectionObject::static_type());
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect(&quot;Could not set collections&quot;);
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(@weak self as window =&gt; @default-panic, move |obj| {
</span><span class="boring">                let collection_object = obj
</span><span class="boring">                    .downcast_ref()
</span><span class="boring">                    .expect(&quot;The object should be of type `CollectionObject`.&quot;);
</span><span class="boring">                let row = window.create_collection_row(collection_object);
</span><span class="boring">                row.upcast()
</span><span class="boring">            }),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    &quot;It should be possible to read `backup_data` from the json file.&quot;,
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property(&quot;title&quot;, &amp;label, &quot;label&quot;)
</span><span class="boring">            .flags(glib::BindingFlags::SYNC_CREATE)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(@weak self as window =&gt; @default-panic, move |obj| {
</span><span class="boring">                let task_object = obj
</span><span class="boring">                    .downcast_ref()
</span><span class="boring">                    .expect(&quot;The object should be of type `TaskObject`.&quot;);
</span><span class="boring">                let row = window.create_task_row(task_object);
</span><span class="boring">                row.upcast()
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(
</span><span class="boring">            clone!(@weak self as window =&gt; move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span>    fn select_collection_row(&amp;self) {
        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
            let row = self.imp().collections_list.row_at_index(index as i32);
            self.imp().collections_list.select_row(row.as_ref());
        }
    }
<span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property(&quot;completed&quot;, &amp;check_button, &quot;active&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE | BindingFlags::BIDIRECTIONAL)
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property(&quot;content&quot;, &amp;row, &quot;title&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp()
</span><span class="boring">            .entry
</span><span class="boring">            .connect_activate(clone!(@weak self as window =&gt; move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_,_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key &quot;filter&quot; changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some(&quot;filter&quot;),
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, _| {
</span><span class="boring">                window.set_filter();
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window.collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect(&quot;There needs to be an object at this position.&quot;)
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect(&quot;The object needs to be a `CollectionObject`.&quot;);
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().leaflet.navigate(NavigationDirection::Forward);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback for folding the leaflet
</span><span class="boring">        self.imp().leaflet.connect_folded_notify(
</span><span class="boring">            clone!(@weak self as window =&gt; move |leaflet| {
</span><span class="boring">                if leaflet.is_folded() {
</span><span class="boring">                    window
</span><span class="boring">                        .imp()
</span><span class="boring">                        .collections_list
</span><span class="boring">                        .set_selection_mode(SelectionMode::None)
</span><span class="boring">                } else {
</span><span class="boring">                    window
</span><span class="boring">                        .imp()
</span><span class="boring">                        .collections_list
</span><span class="boring">                        .set_selection_mode(SelectionMode::Single);
</span><span class="boring">                    window.select_collection_row();
</span><span class="boring">                }
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        self.imp().back_button.connect_clicked(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_| {
</span><span class="boring">                window.imp().leaflet.navigate(NavigationDirection::Back);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name(&quot;main&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name(&quot;placeholder&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text(&quot;&quot;);
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key &quot;filter&quot; and add to action group &quot;win&quot;
</span><span class="boring">        let action_filter = self.settings().create_action(&quot;filter&quot;);
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group &quot;win&quot;
</span><span class="boring">        let action_remove_done_tasks =
</span><span class="boring">            gio::SimpleAction::new(&quot;remove-done-tasks&quot;, None);
</span><span class="boring">        action_remove_done_tasks.connect_activate(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, _| {
</span><span class="boring">                let tasks = window.tasks();
</span><span class="boring">                let mut position = 0;
</span><span class="boring">                while let Some(item) = tasks.item(position) {
</span><span class="boring">                    // Get `TaskObject` from `glib::Object`
</span><span class="boring">                    let task_object = item
</span><span class="boring">                        .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                        .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">                    if task_object.is_completed() {
</span><span class="boring">                        tasks.remove(position);
</span><span class="boring">                    } else {
</span><span class="boring">                        position += 1;
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">        self.add_action(&amp;action_remove_done_tasks);
</span><span class="boring">
</span><span class="boring">        // Create action to create new collection and add to action group &quot;win&quot;
</span><span class="boring">        let action_new_list = gio::SimpleAction::new(&quot;new-collection&quot;, None);
</span><span class="boring">        action_new_list.connect_activate(clone!(@weak self as window =&gt; move |_, _| {
</span><span class="boring">            window.new_collection();
</span><span class="boring">        }));
</span><span class="boring">        self.add_action(&amp;action_new_list);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_collection(&amp;self) {
</span><span class="boring">        // Create new Dialog
</span><span class="boring">        let dialog = Dialog::with_buttons(
</span><span class="boring">            Some(&quot;New Collection&quot;),
</span><span class="boring">            Some(self),
</span><span class="boring">            DialogFlags::MODAL
</span><span class="boring">                | DialogFlags::DESTROY_WITH_PARENT
</span><span class="boring">                | DialogFlags::USE_HEADER_BAR,
</span><span class="boring">            &amp;[
</span><span class="boring">                (&quot;Cancel&quot;, ResponseType::Cancel),
</span><span class="boring">                (&quot;Create&quot;, ResponseType::Accept),
</span><span class="boring">            ],
</span><span class="boring">        );
</span><span class="boring">        dialog.set_default_response(ResponseType::Accept);
</span><span class="boring">
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        let dialog_button = dialog
</span><span class="boring">            .widget_for_response(ResponseType::Accept)
</span><span class="boring">            .expect(&quot;The dialog needs to have a widget for response type `Accept`.&quot;);
</span><span class="boring">        dialog_button.set_sensitive(false);
</span><span class="boring">
</span><span class="boring">        // Create entry and add it to the dialog
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .margin_top(12)
</span><span class="boring">            .margin_bottom(12)
</span><span class="boring">            .margin_start(12)
</span><span class="boring">            .margin_end(12)
</span><span class="boring">            .placeholder_text(&quot;Name&quot;)
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">        dialog.content_area().append(&amp;entry);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to &quot;error&quot;, when there is not text in it
</span><span class="boring">        entry.connect_changed(clone!(@weak dialog =&gt; move |entry| {
</span><span class="boring">            let text = entry.text();
</span><span class="boring">            let dialog_button = dialog.
</span><span class="boring">                widget_for_response(ResponseType::Accept).
</span><span class="boring">                expect(&quot;The dialog needs to have a widget for response type `Accept`.&quot;);
</span><span class="boring">            let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">            dialog_button.set_sensitive(!empty);
</span><span class="boring">
</span><span class="boring">            if empty {
</span><span class="boring">                entry.add_css_class(&quot;error&quot;);
</span><span class="boring">            } else {
</span><span class="boring">                entry.remove_css_class(&quot;error&quot;);
</span><span class="boring">            }
</span><span class="boring">        }));
</span><span class="boring">
</span><span class="boring">        // Connect response to dialog
</span><span class="boring">        dialog.connect_response(
</span><span class="boring">            clone!(@weak self as window, @weak entry =&gt; move |dialog, response| {
</span><span class="boring">                // Destroy dialog
</span><span class="boring">                dialog.destroy();
</span><span class="boring">
</span><span class="boring">                // Return if the user chose a response different than `Accept`
</span><span class="boring">                if response != ResponseType::Accept {
</span><span class="boring">                    return;
</span><span class="boring">                }
</span><span class="boring">
</span><span class="boring">                // Create a new list store
</span><span class="boring">                let tasks = gio::ListStore::new(TaskObject::static_type());
</span><span class="boring">
</span><span class="boring">                // Create a new collection object from the title the user provided
</span><span class="boring">                let title = entry.text().to_string();
</span><span class="boring">                let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">                // Add new collection object and set current tasks
</span><span class="boring">                window.collections().append(&amp;collection);
</span><span class="boring">                window.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">                // Let the leaflet navigate to the next child
</span><span class="boring">                window.imp().leaflet.navigate(NavigationDirection::Forward);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">        dialog.present();
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<h2 id="leaflet-and-dialog"><a class="header" href="#leaflet-and-dialog">Leaflet and Dialog</a></h2>
<p>Thanks to the leaflet the To-Do app folds now when we resize it to a smaller width.
However, there isn't yet a way to navigate between the different leaflet pages.
Let us start with the most important one: adding a new collection.</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/todo_8_dialog.webm" type="video/webm">
   <p>A video which shows the new dialog</p>
 </video>
</div>
<p>The screencast above demonstrates the desired behavior.
When we activate the button with the <code>+</code> symbol, a dialog appears.
While the entry is empty, the &quot;Create&quot; button remains insensitive.
As soon as we start typing, the button becomes sensitive.
When we remove all typed letters and the entry becomes empty again, the &quot;Create&quot; button becomes insensitive and the entry gets the &quot;error&quot; style.
After clicking the &quot;Create&quot; button, a new collection is created, and we navigate to its task view.</p>
<p>To implement that behavior we will first add a &quot;new-collection&quot; action to the <code>setup_actions</code> method.
This action will be activated by a click on the <code>+</code> button as well as on the button in the placeholder page.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, NavigationDirection};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::glib::BindingFlags;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Dialog, DialogFlags, Entry,
</span><span class="boring">    FilterListModel, Label, ListBoxRow, NoSelection, ResponseType, SelectionMode,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property(&quot;application&quot;, app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect(&quot;`settings` should not be set before calling `setup_settings`.&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect(&quot;`settings` should be set in `setup_settings`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect(&quot;`current_collection` should be set in `set_current_collections`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect(&quot;`collections` should be set in `setup_collections`.&quot;)
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect(&quot;`current_filter_model` should be set in `set_current_collection`.&quot;)
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get(&quot;filter&quot;);
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            &quot;All&quot; =&gt; None,
</span><span class="boring">            &quot;Open&quot; =&gt; Some(filter_open),
</span><span class="boring">            &quot;Done&quot; =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new(CollectionObject::static_type());
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect(&quot;Could not set collections&quot;);
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(@weak self as window =&gt; @default-panic, move |obj| {
</span><span class="boring">                let collection_object = obj
</span><span class="boring">                    .downcast_ref()
</span><span class="boring">                    .expect(&quot;The object should be of type `CollectionObject`.&quot;);
</span><span class="boring">                let row = window.create_collection_row(collection_object);
</span><span class="boring">                row.upcast()
</span><span class="boring">            }),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    &quot;It should be possible to read `backup_data` from the json file.&quot;,
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property(&quot;title&quot;, &amp;label, &quot;label&quot;)
</span><span class="boring">            .flags(glib::BindingFlags::SYNC_CREATE)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(@weak self as window =&gt; @default-panic, move |obj| {
</span><span class="boring">                let task_object = obj
</span><span class="boring">                    .downcast_ref()
</span><span class="boring">                    .expect(&quot;The object should be of type `TaskObject`.&quot;);
</span><span class="boring">                let row = window.create_task_row(task_object);
</span><span class="boring">                row.upcast()
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(
</span><span class="boring">            clone!(@weak self as window =&gt; move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property(&quot;completed&quot;, &amp;check_button, &quot;active&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE | BindingFlags::BIDIRECTIONAL)
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property(&quot;content&quot;, &amp;row, &quot;title&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp()
</span><span class="boring">            .entry
</span><span class="boring">            .connect_activate(clone!(@weak self as window =&gt; move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_,_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key &quot;filter&quot; changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some(&quot;filter&quot;),
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, _| {
</span><span class="boring">                window.set_filter();
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window.collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect(&quot;There needs to be an object at this position.&quot;)
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect(&quot;The object needs to be a `CollectionObject`.&quot;);
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().leaflet.navigate(NavigationDirection::Forward);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback for folding the leaflet
</span><span class="boring">        self.imp().leaflet.connect_folded_notify(
</span><span class="boring">            clone!(@weak self as window =&gt; move |leaflet| {
</span><span class="boring">                if leaflet.is_folded() {
</span><span class="boring">                    window
</span><span class="boring">                        .imp()
</span><span class="boring">                        .collections_list
</span><span class="boring">                        .set_selection_mode(SelectionMode::None)
</span><span class="boring">                } else {
</span><span class="boring">                    window
</span><span class="boring">                        .imp()
</span><span class="boring">                        .collections_list
</span><span class="boring">                        .set_selection_mode(SelectionMode::Single);
</span><span class="boring">                    window.select_collection_row();
</span><span class="boring">                }
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        self.imp().back_button.connect_clicked(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_| {
</span><span class="boring">                window.imp().leaflet.navigate(NavigationDirection::Back);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name(&quot;main&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name(&quot;placeholder&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text(&quot;&quot;);
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key &quot;filter&quot; and add to action group &quot;win&quot;
</span><span class="boring">        let action_filter = self.settings().create_action(&quot;filter&quot;);
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group &quot;win&quot;
</span><span class="boring">        let action_remove_done_tasks =
</span><span class="boring">            gio::SimpleAction::new(&quot;remove-done-tasks&quot;, None);
</span><span class="boring">        action_remove_done_tasks.connect_activate(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, _| {
</span><span class="boring">                let tasks = window.tasks();
</span><span class="boring">                let mut position = 0;
</span><span class="boring">                while let Some(item) = tasks.item(position) {
</span><span class="boring">                    // Get `TaskObject` from `glib::Object`
</span><span class="boring">                    let task_object = item
</span><span class="boring">                        .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                        .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">                    if task_object.is_completed() {
</span><span class="boring">                        tasks.remove(position);
</span><span class="boring">                    } else {
</span><span class="boring">                        position += 1;
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">        self.add_action(&amp;action_remove_done_tasks);
</span><span class="boring">
</span>        // Create action to create new collection and add to action group &quot;win&quot;
        let action_new_list = gio::SimpleAction::new(&quot;new-collection&quot;, None);
        action_new_list.connect_activate(clone!(@weak self as window =&gt; move |_, _| {
            window.new_collection();
        }));
        self.add_action(&amp;action_new_list);
<span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_collection(&amp;self) {
</span><span class="boring">        // Create new Dialog
</span><span class="boring">        let dialog = Dialog::with_buttons(
</span><span class="boring">            Some(&quot;New Collection&quot;),
</span><span class="boring">            Some(self),
</span><span class="boring">            DialogFlags::MODAL
</span><span class="boring">                | DialogFlags::DESTROY_WITH_PARENT
</span><span class="boring">                | DialogFlags::USE_HEADER_BAR,
</span><span class="boring">            &amp;[
</span><span class="boring">                (&quot;Cancel&quot;, ResponseType::Cancel),
</span><span class="boring">                (&quot;Create&quot;, ResponseType::Accept),
</span><span class="boring">            ],
</span><span class="boring">        );
</span><span class="boring">        dialog.set_default_response(ResponseType::Accept);
</span><span class="boring">
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        let dialog_button = dialog
</span><span class="boring">            .widget_for_response(ResponseType::Accept)
</span><span class="boring">            .expect(&quot;The dialog needs to have a widget for response type `Accept`.&quot;);
</span><span class="boring">        dialog_button.set_sensitive(false);
</span><span class="boring">
</span><span class="boring">        // Create entry and add it to the dialog
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .margin_top(12)
</span><span class="boring">            .margin_bottom(12)
</span><span class="boring">            .margin_start(12)
</span><span class="boring">            .margin_end(12)
</span><span class="boring">            .placeholder_text(&quot;Name&quot;)
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">        dialog.content_area().append(&amp;entry);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to &quot;error&quot;, when there is not text in it
</span><span class="boring">        entry.connect_changed(clone!(@weak dialog =&gt; move |entry| {
</span><span class="boring">            let text = entry.text();
</span><span class="boring">            let dialog_button = dialog.
</span><span class="boring">                widget_for_response(ResponseType::Accept).
</span><span class="boring">                expect(&quot;The dialog needs to have a widget for response type `Accept`.&quot;);
</span><span class="boring">            let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">            dialog_button.set_sensitive(!empty);
</span><span class="boring">
</span><span class="boring">            if empty {
</span><span class="boring">                entry.add_css_class(&quot;error&quot;);
</span><span class="boring">            } else {
</span><span class="boring">                entry.remove_css_class(&quot;error&quot;);
</span><span class="boring">            }
</span><span class="boring">        }));
</span><span class="boring">
</span><span class="boring">        // Connect response to dialog
</span><span class="boring">        dialog.connect_response(
</span><span class="boring">            clone!(@weak self as window, @weak entry =&gt; move |dialog, response| {
</span><span class="boring">                // Destroy dialog
</span><span class="boring">                dialog.destroy();
</span><span class="boring">
</span><span class="boring">                // Return if the user chose a response different than `Accept`
</span><span class="boring">                if response != ResponseType::Accept {
</span><span class="boring">                    return;
</span><span class="boring">                }
</span><span class="boring">
</span><span class="boring">                // Create a new list store
</span><span class="boring">                let tasks = gio::ListStore::new(TaskObject::static_type());
</span><span class="boring">
</span><span class="boring">                // Create a new collection object from the title the user provided
</span><span class="boring">                let title = entry.text().to_string();
</span><span class="boring">                let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">                // Add new collection object and set current tasks
</span><span class="boring">                window.collections().append(&amp;collection);
</span><span class="boring">                window.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">                // Let the leaflet navigate to the next child
</span><span class="boring">                window.imp().leaflet.navigate(NavigationDirection::Forward);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">        dialog.present();
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>As soon as the &quot;new-collection&quot; action is activated, the <code>new_collection</code> method is called.
Here, we create the dialog, set up the buttons as well as add the entry to it.
We add a callback to the entry to ensure that when the content changes, an empty content sets <code>dialog_button</code> as insensitive and adds an &quot;error&quot; CSS class to the entry.
We also add a callback to the dialog itself.
If we click &quot;Cancel&quot;, the dialog should just be destroyed without any further actions.
However, if we click &quot;Create&quot;, we want a new collection to be created and set as current collection.
Afterwards we navigate forward on our leaflet, which means we navigate to the task view.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, NavigationDirection};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::glib::BindingFlags;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Dialog, DialogFlags, Entry,
</span><span class="boring">    FilterListModel, Label, ListBoxRow, NoSelection, ResponseType, SelectionMode,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property(&quot;application&quot;, app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect(&quot;`settings` should not be set before calling `setup_settings`.&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect(&quot;`settings` should be set in `setup_settings`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect(&quot;`current_collection` should be set in `set_current_collections`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect(&quot;`collections` should be set in `setup_collections`.&quot;)
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect(&quot;`current_filter_model` should be set in `set_current_collection`.&quot;)
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get(&quot;filter&quot;);
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            &quot;All&quot; =&gt; None,
</span><span class="boring">            &quot;Open&quot; =&gt; Some(filter_open),
</span><span class="boring">            &quot;Done&quot; =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new(CollectionObject::static_type());
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect(&quot;Could not set collections&quot;);
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(@weak self as window =&gt; @default-panic, move |obj| {
</span><span class="boring">                let collection_object = obj
</span><span class="boring">                    .downcast_ref()
</span><span class="boring">                    .expect(&quot;The object should be of type `CollectionObject`.&quot;);
</span><span class="boring">                let row = window.create_collection_row(collection_object);
</span><span class="boring">                row.upcast()
</span><span class="boring">            }),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    &quot;It should be possible to read `backup_data` from the json file.&quot;,
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property(&quot;title&quot;, &amp;label, &quot;label&quot;)
</span><span class="boring">            .flags(glib::BindingFlags::SYNC_CREATE)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(@weak self as window =&gt; @default-panic, move |obj| {
</span><span class="boring">                let task_object = obj
</span><span class="boring">                    .downcast_ref()
</span><span class="boring">                    .expect(&quot;The object should be of type `TaskObject`.&quot;);
</span><span class="boring">                let row = window.create_task_row(task_object);
</span><span class="boring">                row.upcast()
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(
</span><span class="boring">            clone!(@weak self as window =&gt; move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property(&quot;completed&quot;, &amp;check_button, &quot;active&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE | BindingFlags::BIDIRECTIONAL)
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property(&quot;content&quot;, &amp;row, &quot;title&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp()
</span><span class="boring">            .entry
</span><span class="boring">            .connect_activate(clone!(@weak self as window =&gt; move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_,_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key &quot;filter&quot; changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some(&quot;filter&quot;),
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, _| {
</span><span class="boring">                window.set_filter();
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window.collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect(&quot;There needs to be an object at this position.&quot;)
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect(&quot;The object needs to be a `CollectionObject`.&quot;);
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().leaflet.navigate(NavigationDirection::Forward);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback for folding the leaflet
</span><span class="boring">        self.imp().leaflet.connect_folded_notify(
</span><span class="boring">            clone!(@weak self as window =&gt; move |leaflet| {
</span><span class="boring">                if leaflet.is_folded() {
</span><span class="boring">                    window
</span><span class="boring">                        .imp()
</span><span class="boring">                        .collections_list
</span><span class="boring">                        .set_selection_mode(SelectionMode::None)
</span><span class="boring">                } else {
</span><span class="boring">                    window
</span><span class="boring">                        .imp()
</span><span class="boring">                        .collections_list
</span><span class="boring">                        .set_selection_mode(SelectionMode::Single);
</span><span class="boring">                    window.select_collection_row();
</span><span class="boring">                }
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        self.imp().back_button.connect_clicked(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_| {
</span><span class="boring">                window.imp().leaflet.navigate(NavigationDirection::Back);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name(&quot;main&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name(&quot;placeholder&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text(&quot;&quot;);
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key &quot;filter&quot; and add to action group &quot;win&quot;
</span><span class="boring">        let action_filter = self.settings().create_action(&quot;filter&quot;);
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group &quot;win&quot;
</span><span class="boring">        let action_remove_done_tasks =
</span><span class="boring">            gio::SimpleAction::new(&quot;remove-done-tasks&quot;, None);
</span><span class="boring">        action_remove_done_tasks.connect_activate(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, _| {
</span><span class="boring">                let tasks = window.tasks();
</span><span class="boring">                let mut position = 0;
</span><span class="boring">                while let Some(item) = tasks.item(position) {
</span><span class="boring">                    // Get `TaskObject` from `glib::Object`
</span><span class="boring">                    let task_object = item
</span><span class="boring">                        .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                        .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">                    if task_object.is_completed() {
</span><span class="boring">                        tasks.remove(position);
</span><span class="boring">                    } else {
</span><span class="boring">                        position += 1;
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">        self.add_action(&amp;action_remove_done_tasks);
</span><span class="boring">
</span><span class="boring">        // Create action to create new collection and add to action group &quot;win&quot;
</span><span class="boring">        let action_new_list = gio::SimpleAction::new(&quot;new-collection&quot;, None);
</span><span class="boring">        action_new_list.connect_activate(clone!(@weak self as window =&gt; move |_, _| {
</span><span class="boring">            window.new_collection();
</span><span class="boring">        }));
</span><span class="boring">        self.add_action(&amp;action_new_list);
</span><span class="boring">    }
</span><span class="boring">
</span>    fn new_collection(&amp;self) {
        // Create new Dialog
        let dialog = Dialog::with_buttons(
            Some(&quot;New Collection&quot;),
            Some(self),
            DialogFlags::MODAL
                | DialogFlags::DESTROY_WITH_PARENT
                | DialogFlags::USE_HEADER_BAR,
            &amp;[
                (&quot;Cancel&quot;, ResponseType::Cancel),
                (&quot;Create&quot;, ResponseType::Accept),
            ],
        );
        dialog.set_default_response(ResponseType::Accept);

        // Make the dialog button insensitive initially
        let dialog_button = dialog
            .widget_for_response(ResponseType::Accept)
            .expect(&quot;The dialog needs to have a widget for response type `Accept`.&quot;);
        dialog_button.set_sensitive(false);

        // Create entry and add it to the dialog
        let entry = Entry::builder()
            .margin_top(12)
            .margin_bottom(12)
            .margin_start(12)
            .margin_end(12)
            .placeholder_text(&quot;Name&quot;)
            .activates_default(true)
            .build();
        dialog.content_area().append(&amp;entry);

        // Set entry's css class to &quot;error&quot;, when there is not text in it
        entry.connect_changed(clone!(@weak dialog =&gt; move |entry| {
            let text = entry.text();
            let dialog_button = dialog.
                widget_for_response(ResponseType::Accept).
                expect(&quot;The dialog needs to have a widget for response type `Accept`.&quot;);
            let empty = text.is_empty();

            dialog_button.set_sensitive(!empty);

            if empty {
                entry.add_css_class(&quot;error&quot;);
            } else {
                entry.remove_css_class(&quot;error&quot;);
            }
        }));

        // Connect response to dialog
        dialog.connect_response(
            clone!(@weak self as window, @weak entry =&gt; move |dialog, response| {
                // Destroy dialog
                dialog.destroy();

                // Return if the user chose a response different than `Accept`
                if response != ResponseType::Accept {
                    return;
                }

                // Create a new list store
                let tasks = gio::ListStore::new(TaskObject::static_type());

                // Create a new collection object from the title the user provided
                let title = entry.text().to_string();
                let collection = CollectionObject::new(&amp;title, tasks);

                // Add new collection object and set current tasks
                window.collections().append(&amp;collection);
                window.set_current_collection(collection);

                // Let the leaflet navigate to the next child
                window.imp().leaflet.navigate(NavigationDirection::Forward);
            }),
        );
        dialog.present();
    }
<span class="boring">}</span></code></pre>
<p>We also add more callbacks to <code>setup_callbacks</code>.
Importantly, we want to filter our current task model whenever the value of the &quot;filter&quot; setting changes.
Whenever the items of our collections change we also want to set the stack.
This makes sure that our placeholder page is shown if there are no collections.
When we click on an item of <code>collections_list</code>, <code>current_collection</code> should be set to the selected collection and we should then navigate to the task view.
That is setup in <code>collections_list.connect_row_activated</code>, but we also need to setup <code>leaflet.connect_folded_notify</code> to make sure that no selection of <code>collections_list</code> items is happening in folded mode so that it just directly moves to the task view.
Finally, we connect to a click of the <code>back_button</code> in the task view so that we can return to the collections view again in folded mode.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, NavigationDirection};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::glib::BindingFlags;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Dialog, DialogFlags, Entry,
</span><span class="boring">    FilterListModel, Label, ListBoxRow, NoSelection, ResponseType, SelectionMode,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property(&quot;application&quot;, app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect(&quot;`settings` should not be set before calling `setup_settings`.&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect(&quot;`settings` should be set in `setup_settings`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect(&quot;`current_collection` should be set in `set_current_collections`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect(&quot;`collections` should be set in `setup_collections`.&quot;)
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect(&quot;`current_filter_model` should be set in `set_current_collection`.&quot;)
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get(&quot;filter&quot;);
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            &quot;All&quot; =&gt; None,
</span><span class="boring">            &quot;Open&quot; =&gt; Some(filter_open),
</span><span class="boring">            &quot;Done&quot; =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new(CollectionObject::static_type());
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect(&quot;Could not set collections&quot;);
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(@weak self as window =&gt; @default-panic, move |obj| {
</span><span class="boring">                let collection_object = obj
</span><span class="boring">                    .downcast_ref()
</span><span class="boring">                    .expect(&quot;The object should be of type `CollectionObject`.&quot;);
</span><span class="boring">                let row = window.create_collection_row(collection_object);
</span><span class="boring">                row.upcast()
</span><span class="boring">            }),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    &quot;It should be possible to read `backup_data` from the json file.&quot;,
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property(&quot;title&quot;, &amp;label, &quot;label&quot;)
</span><span class="boring">            .flags(glib::BindingFlags::SYNC_CREATE)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(@weak self as window =&gt; @default-panic, move |obj| {
</span><span class="boring">                let task_object = obj
</span><span class="boring">                    .downcast_ref()
</span><span class="boring">                    .expect(&quot;The object should be of type `TaskObject`.&quot;);
</span><span class="boring">                let row = window.create_task_row(task_object);
</span><span class="boring">                row.upcast()
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(
</span><span class="boring">            clone!(@weak self as window =&gt; move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property(&quot;completed&quot;, &amp;check_button, &quot;active&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE | BindingFlags::BIDIRECTIONAL)
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property(&quot;content&quot;, &amp;row, &quot;title&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp()
</span><span class="boring">            .entry
</span><span class="boring">            .connect_activate(clone!(@weak self as window =&gt; move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_,_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span>        // Filter model whenever the value of the key &quot;filter&quot; changes
        self.settings().connect_changed(
            Some(&quot;filter&quot;),
            clone!(@weak self as window =&gt; move |_, _| {
                window.set_filter();
            }),
        );

        // Setup callback when items of collections change
        self.set_stack();
        self.collections().connect_items_changed(
            clone!(@weak self as window =&gt; move |_, _, _, _| {
                window.set_stack();
            }),
        );

        // Setup callback for activating a row of collections list
        self.imp().collections_list.connect_row_activated(
            clone!(@weak self as window =&gt; move |_, row| {
                let index = row.index();
                let selected_collection = window.collections()
                    .item(index as u32)
                    .expect(&quot;There needs to be an object at this position.&quot;)
                    .downcast::&lt;CollectionObject&gt;()
                    .expect(&quot;The object needs to be a `CollectionObject`.&quot;);
                window.set_current_collection(selected_collection);
                window.imp().leaflet.navigate(NavigationDirection::Forward);
            }),
        );

        // Setup callback for folding the leaflet
        self.imp().leaflet.connect_folded_notify(
            clone!(@weak self as window =&gt; move |leaflet| {
                if leaflet.is_folded() {
                    window
                        .imp()
                        .collections_list
                        .set_selection_mode(SelectionMode::None)
                } else {
                    window
                        .imp()
                        .collections_list
                        .set_selection_mode(SelectionMode::Single);
                    window.select_collection_row();
                }
            }),
        );

        self.imp().back_button.connect_clicked(
            clone!(@weak self as window =&gt; move |_| {
                window.imp().leaflet.navigate(NavigationDirection::Back);
            }),
        );
<span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name(&quot;main&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name(&quot;placeholder&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text(&quot;&quot;);
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key &quot;filter&quot; and add to action group &quot;win&quot;
</span><span class="boring">        let action_filter = self.settings().create_action(&quot;filter&quot;);
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group &quot;win&quot;
</span><span class="boring">        let action_remove_done_tasks =
</span><span class="boring">            gio::SimpleAction::new(&quot;remove-done-tasks&quot;, None);
</span><span class="boring">        action_remove_done_tasks.connect_activate(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, _| {
</span><span class="boring">                let tasks = window.tasks();
</span><span class="boring">                let mut position = 0;
</span><span class="boring">                while let Some(item) = tasks.item(position) {
</span><span class="boring">                    // Get `TaskObject` from `glib::Object`
</span><span class="boring">                    let task_object = item
</span><span class="boring">                        .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                        .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">                    if task_object.is_completed() {
</span><span class="boring">                        tasks.remove(position);
</span><span class="boring">                    } else {
</span><span class="boring">                        position += 1;
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">        self.add_action(&amp;action_remove_done_tasks);
</span><span class="boring">
</span><span class="boring">        // Create action to create new collection and add to action group &quot;win&quot;
</span><span class="boring">        let action_new_list = gio::SimpleAction::new(&quot;new-collection&quot;, None);
</span><span class="boring">        action_new_list.connect_activate(clone!(@weak self as window =&gt; move |_, _| {
</span><span class="boring">            window.new_collection();
</span><span class="boring">        }));
</span><span class="boring">        self.add_action(&amp;action_new_list);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_collection(&amp;self) {
</span><span class="boring">        // Create new Dialog
</span><span class="boring">        let dialog = Dialog::with_buttons(
</span><span class="boring">            Some(&quot;New Collection&quot;),
</span><span class="boring">            Some(self),
</span><span class="boring">            DialogFlags::MODAL
</span><span class="boring">                | DialogFlags::DESTROY_WITH_PARENT
</span><span class="boring">                | DialogFlags::USE_HEADER_BAR,
</span><span class="boring">            &amp;[
</span><span class="boring">                (&quot;Cancel&quot;, ResponseType::Cancel),
</span><span class="boring">                (&quot;Create&quot;, ResponseType::Accept),
</span><span class="boring">            ],
</span><span class="boring">        );
</span><span class="boring">        dialog.set_default_response(ResponseType::Accept);
</span><span class="boring">
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        let dialog_button = dialog
</span><span class="boring">            .widget_for_response(ResponseType::Accept)
</span><span class="boring">            .expect(&quot;The dialog needs to have a widget for response type `Accept`.&quot;);
</span><span class="boring">        dialog_button.set_sensitive(false);
</span><span class="boring">
</span><span class="boring">        // Create entry and add it to the dialog
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .margin_top(12)
</span><span class="boring">            .margin_bottom(12)
</span><span class="boring">            .margin_start(12)
</span><span class="boring">            .margin_end(12)
</span><span class="boring">            .placeholder_text(&quot;Name&quot;)
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">        dialog.content_area().append(&amp;entry);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to &quot;error&quot;, when there is not text in it
</span><span class="boring">        entry.connect_changed(clone!(@weak dialog =&gt; move |entry| {
</span><span class="boring">            let text = entry.text();
</span><span class="boring">            let dialog_button = dialog.
</span><span class="boring">                widget_for_response(ResponseType::Accept).
</span><span class="boring">                expect(&quot;The dialog needs to have a widget for response type `Accept`.&quot;);
</span><span class="boring">            let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">            dialog_button.set_sensitive(!empty);
</span><span class="boring">
</span><span class="boring">            if empty {
</span><span class="boring">                entry.add_css_class(&quot;error&quot;);
</span><span class="boring">            } else {
</span><span class="boring">                entry.remove_css_class(&quot;error&quot;);
</span><span class="boring">            }
</span><span class="boring">        }));
</span><span class="boring">
</span><span class="boring">        // Connect response to dialog
</span><span class="boring">        dialog.connect_response(
</span><span class="boring">            clone!(@weak self as window, @weak entry =&gt; move |dialog, response| {
</span><span class="boring">                // Destroy dialog
</span><span class="boring">                dialog.destroy();
</span><span class="boring">
</span><span class="boring">                // Return if the user chose a response different than `Accept`
</span><span class="boring">                if response != ResponseType::Accept {
</span><span class="boring">                    return;
</span><span class="boring">                }
</span><span class="boring">
</span><span class="boring">                // Create a new list store
</span><span class="boring">                let tasks = gio::ListStore::new(TaskObject::static_type());
</span><span class="boring">
</span><span class="boring">                // Create a new collection object from the title the user provided
</span><span class="boring">                let title = entry.text().to_string();
</span><span class="boring">                let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">                // Add new collection object and set current tasks
</span><span class="boring">                window.collections().append(&amp;collection);
</span><span class="boring">                window.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">                // Let the leaflet navigate to the next child
</span><span class="boring">                window.imp().leaflet.navigate(NavigationDirection::Forward);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">        dialog.present();
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Before, we called the method <code>set_stack</code>.
This method ensure when there is at least one collection, the &quot;main&quot; page is shown, and the &quot;placeholder&quot; page otherwise.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, NavigationDirection};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::glib::BindingFlags;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Dialog, DialogFlags, Entry,
</span><span class="boring">    FilterListModel, Label, ListBoxRow, NoSelection, ResponseType, SelectionMode,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property(&quot;application&quot;, app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect(&quot;`settings` should not be set before calling `setup_settings`.&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect(&quot;`settings` should be set in `setup_settings`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect(&quot;`current_collection` should be set in `set_current_collections`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect(&quot;`collections` should be set in `setup_collections`.&quot;)
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect(&quot;`current_filter_model` should be set in `set_current_collection`.&quot;)
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get(&quot;filter&quot;);
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            &quot;All&quot; =&gt; None,
</span><span class="boring">            &quot;Open&quot; =&gt; Some(filter_open),
</span><span class="boring">            &quot;Done&quot; =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new(CollectionObject::static_type());
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect(&quot;Could not set collections&quot;);
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(@weak self as window =&gt; @default-panic, move |obj| {
</span><span class="boring">                let collection_object = obj
</span><span class="boring">                    .downcast_ref()
</span><span class="boring">                    .expect(&quot;The object should be of type `CollectionObject`.&quot;);
</span><span class="boring">                let row = window.create_collection_row(collection_object);
</span><span class="boring">                row.upcast()
</span><span class="boring">            }),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    &quot;It should be possible to read `backup_data` from the json file.&quot;,
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property(&quot;title&quot;, &amp;label, &quot;label&quot;)
</span><span class="boring">            .flags(glib::BindingFlags::SYNC_CREATE)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(@weak self as window =&gt; @default-panic, move |obj| {
</span><span class="boring">                let task_object = obj
</span><span class="boring">                    .downcast_ref()
</span><span class="boring">                    .expect(&quot;The object should be of type `TaskObject`.&quot;);
</span><span class="boring">                let row = window.create_task_row(task_object);
</span><span class="boring">                row.upcast()
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(
</span><span class="boring">            clone!(@weak self as window =&gt; move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property(&quot;completed&quot;, &amp;check_button, &quot;active&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE | BindingFlags::BIDIRECTIONAL)
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property(&quot;content&quot;, &amp;row, &quot;title&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp()
</span><span class="boring">            .entry
</span><span class="boring">            .connect_activate(clone!(@weak self as window =&gt; move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_,_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key &quot;filter&quot; changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some(&quot;filter&quot;),
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, _| {
</span><span class="boring">                window.set_filter();
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window.collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect(&quot;There needs to be an object at this position.&quot;)
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect(&quot;The object needs to be a `CollectionObject`.&quot;);
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().leaflet.navigate(NavigationDirection::Forward);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback for folding the leaflet
</span><span class="boring">        self.imp().leaflet.connect_folded_notify(
</span><span class="boring">            clone!(@weak self as window =&gt; move |leaflet| {
</span><span class="boring">                if leaflet.is_folded() {
</span><span class="boring">                    window
</span><span class="boring">                        .imp()
</span><span class="boring">                        .collections_list
</span><span class="boring">                        .set_selection_mode(SelectionMode::None)
</span><span class="boring">                } else {
</span><span class="boring">                    window
</span><span class="boring">                        .imp()
</span><span class="boring">                        .collections_list
</span><span class="boring">                        .set_selection_mode(SelectionMode::Single);
</span><span class="boring">                    window.select_collection_row();
</span><span class="boring">                }
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        self.imp().back_button.connect_clicked(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_| {
</span><span class="boring">                window.imp().leaflet.navigate(NavigationDirection::Back);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span>    fn set_stack(&amp;self) {
        if self.collections().n_items() &gt; 0 {
            self.imp().stack.set_visible_child_name(&quot;main&quot;);
        } else {
            self.imp().stack.set_visible_child_name(&quot;placeholder&quot;);
        }
    }
<span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text(&quot;&quot;);
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key &quot;filter&quot; and add to action group &quot;win&quot;
</span><span class="boring">        let action_filter = self.settings().create_action(&quot;filter&quot;);
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group &quot;win&quot;
</span><span class="boring">        let action_remove_done_tasks =
</span><span class="boring">            gio::SimpleAction::new(&quot;remove-done-tasks&quot;, None);
</span><span class="boring">        action_remove_done_tasks.connect_activate(
</span><span class="boring">            clone!(@weak self as window =&gt; move |_, _| {
</span><span class="boring">                let tasks = window.tasks();
</span><span class="boring">                let mut position = 0;
</span><span class="boring">                while let Some(item) = tasks.item(position) {
</span><span class="boring">                    // Get `TaskObject` from `glib::Object`
</span><span class="boring">                    let task_object = item
</span><span class="boring">                        .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                        .expect(&quot;The object needs to be of type `TaskObject`.&quot;);
</span><span class="boring">
</span><span class="boring">                    if task_object.is_completed() {
</span><span class="boring">                        tasks.remove(position);
</span><span class="boring">                    } else {
</span><span class="boring">                        position += 1;
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">        self.add_action(&amp;action_remove_done_tasks);
</span><span class="boring">
</span><span class="boring">        // Create action to create new collection and add to action group &quot;win&quot;
</span><span class="boring">        let action_new_list = gio::SimpleAction::new(&quot;new-collection&quot;, None);
</span><span class="boring">        action_new_list.connect_activate(clone!(@weak self as window =&gt; move |_, _| {
</span><span class="boring">            window.new_collection();
</span><span class="boring">        }));
</span><span class="boring">        self.add_action(&amp;action_new_list);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_collection(&amp;self) {
</span><span class="boring">        // Create new Dialog
</span><span class="boring">        let dialog = Dialog::with_buttons(
</span><span class="boring">            Some(&quot;New Collection&quot;),
</span><span class="boring">            Some(self),
</span><span class="boring">            DialogFlags::MODAL
</span><span class="boring">                | DialogFlags::DESTROY_WITH_PARENT
</span><span class="boring">                | DialogFlags::USE_HEADER_BAR,
</span><span class="boring">            &amp;[
</span><span class="boring">                (&quot;Cancel&quot;, ResponseType::Cancel),
</span><span class="boring">                (&quot;Create&quot;, ResponseType::Accept),
</span><span class="boring">            ],
</span><span class="boring">        );
</span><span class="boring">        dialog.set_default_response(ResponseType::Accept);
</span><span class="boring">
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        let dialog_button = dialog
</span><span class="boring">            .widget_for_response(ResponseType::Accept)
</span><span class="boring">            .expect(&quot;The dialog needs to have a widget for response type `Accept`.&quot;);
</span><span class="boring">        dialog_button.set_sensitive(false);
</span><span class="boring">
</span><span class="boring">        // Create entry and add it to the dialog
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .margin_top(12)
</span><span class="boring">            .margin_bottom(12)
</span><span class="boring">            .margin_start(12)
</span><span class="boring">            .margin_end(12)
</span><span class="boring">            .placeholder_text(&quot;Name&quot;)
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">        dialog.content_area().append(&amp;entry);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to &quot;error&quot;, when there is not text in it
</span><span class="boring">        entry.connect_changed(clone!(@weak dialog =&gt; move |entry| {
</span><span class="boring">            let text = entry.text();
</span><span class="boring">            let dialog_button = dialog.
</span><span class="boring">                widget_for_response(ResponseType::Accept).
</span><span class="boring">                expect(&quot;The dialog needs to have a widget for response type `Accept`.&quot;);
</span><span class="boring">            let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">            dialog_button.set_sensitive(!empty);
</span><span class="boring">
</span><span class="boring">            if empty {
</span><span class="boring">                entry.add_css_class(&quot;error&quot;);
</span><span class="boring">            } else {
</span><span class="boring">                entry.remove_css_class(&quot;error&quot;);
</span><span class="boring">            }
</span><span class="boring">        }));
</span><span class="boring">
</span><span class="boring">        // Connect response to dialog
</span><span class="boring">        dialog.connect_response(
</span><span class="boring">            clone!(@weak self as window, @weak entry =&gt; move |dialog, response| {
</span><span class="boring">                // Destroy dialog
</span><span class="boring">                dialog.destroy();
</span><span class="boring">
</span><span class="boring">                // Return if the user chose a response different than `Accept`
</span><span class="boring">                if response != ResponseType::Accept {
</span><span class="boring">                    return;
</span><span class="boring">                }
</span><span class="boring">
</span><span class="boring">                // Create a new list store
</span><span class="boring">                let tasks = gio::ListStore::new(TaskObject::static_type());
</span><span class="boring">
</span><span class="boring">                // Create a new collection object from the title the user provided
</span><span class="boring">                let title = entry.text().to_string();
</span><span class="boring">                let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">                // Add new collection object and set current tasks
</span><span class="boring">                window.collections().append(&amp;collection);
</span><span class="boring">                window.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">                // Let the leaflet navigate to the next child
</span><span class="boring">                window.imp().leaflet.navigate(NavigationDirection::Forward);
</span><span class="boring">            }),
</span><span class="boring">        );
</span><span class="boring">        dialog.present();
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>And that was it!
Now we can enjoy the final result.</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/todo_8_adaptive_sidebar.webm" type="video/webm">
   <p>A video which shows the final To-Do app</p>
 </video>
</div>
<blockquote>
<p>You might have noticed that there is not yet a way to remove a collection.
Try to implement this missing piece of functionality in your local version of the To-Do app.
Which edge cases do you have to consider?</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="todo_3.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="todo_3.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
